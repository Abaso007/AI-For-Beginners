<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "6bbd632dfe6c62e5f66bb51fd78c174a",
  "translation_date": "2025-09-23T12:55:01+00:00",
  "source_file": "lessons/6-Other/21-GeneticAlgorithms/README.md",
  "language_code": "tw"
}
-->
# 遺傳演算法

## [課前測驗](https://ff-quizzes.netlify.app/en/ai/quiz/41)

**遺傳演算法**（Genetic Algorithms, GA）基於一種**進化式方法**來解決人工智慧問題，通過模擬種群的進化過程來尋找給定問題的最佳解。該方法由[約翰·亨利·霍蘭德](https://wikipedia.org/wiki/John_Henry_Holland)於1975年提出。

遺傳演算法的核心思想包括以下幾點：

* 問題的有效解可以用**基因**來表示
* **交叉**（Crossover）允許我們將兩個解結合起來，生成一個新的有效解
* **選擇**（Selection）通過某種**適應度函數**來選擇更優的解
* **突變**（Mutation）用於打破局部最小值的限制，幫助優化過程跳出局部最優解

如果你想實現一個遺傳演算法，需要以下幾個步驟：

* 找到一種方法，使用**基因** g∈Γ 來編碼問題的解
* 在基因集合 Γ 上定義**適應度函數** fit: Γ→**R**，函數值越小表示解越優
* 定義**交叉**機制，用於結合兩個基因生成新解 crossover: Γ²→Γ
* 定義**突變**機制 mutate: Γ→Γ

在許多情況下，交叉和突變的實現通常是對基因作為數字序列或位向量進行簡單操作的算法。

遺傳演算法的具體實現可能因情境而異，但其整體結構如下：

1. 選擇初始種群 G⊆Γ
2. 隨機選擇本步驟將執行的操作：交叉或突變
3. **交叉**：
   * 隨機選擇兩個基因 g₁, g₂ ∈ G
   * 計算交叉結果 g=crossover(g₁, g₂)
   * 如果 fit(g)<fit(g₁) 或 fit(g)<fit(g₂)，則用 g 替換種群中的相應基因
4. **突變**：隨機選擇一個基因 g∈G，並用 mutate(g) 替換它
5. 重複步驟2，直到獲得足夠小的適應度值，或者達到步驟數限制

## 常見任務

遺傳演算法通常用於解決以下任務：

1. 排程優化
2. 最佳裝箱問題
3. 最佳切割問題
4. 加速窮舉搜索

## ✍️ 練習：遺傳演算法

通過以下筆記本繼續學習：

前往[這個筆記本](Genetic.ipynb)，查看使用遺傳演算法的兩個例子：

1. 公平分配寶藏
2. 八皇后問題

## 總結

遺傳演算法被用於解決許多問題，包括物流和搜索問題。這一領域的靈感來自於心理學和計算機科學的交叉研究。

## 🚀 挑戰

「遺傳演算法易於實現，但其行為難以理解。」[來源](https://wikipedia.org/wiki/Genetic_algorithm)  
進行一些研究，找到一個遺傳演算法的實現（例如解數獨問題），並用草圖或流程圖解釋其工作原理。

## [課後測驗](https://ff-quizzes.netlify.app/en/ai/quiz/42)

## 回顧與自學

觀看[這個精彩的影片](https://www.youtube.com/watch?v=qv6UVOQ0F44)，了解計算機如何通過使用遺傳演算法訓練的神經網絡學習玩《超級瑪利歐》。我們將在[下一節](../22-DeepRL/README.md)中學習更多關於計算機學習玩遊戲的內容。

## [作業：丟番圖方程](Diophantine.ipynb)

你的目標是解決所謂的**丟番圖方程**——一種具有整數根的方程。例如，考慮方程 a+2b+3c+4d=30，你需要找到滿足該方程的整數根。

*此作業靈感來自[這篇文章](https://habr.com/post/128704/)。*

提示：

1. 你可以考慮根的範圍為 [0;30]
2. 作為基因，可以考慮使用根值的列表

使用 [Diophantine.ipynb](Diophantine.ipynb) 作為起點。

---

