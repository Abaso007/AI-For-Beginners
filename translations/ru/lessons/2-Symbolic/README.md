<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "7d097f7fda9166ead615e4c34552381b",
  "translation_date": "2025-09-23T07:59:39+00:00",
  "source_file": "lessons/2-Symbolic/README.md",
  "language_code": "ru"
}
-->
# Представление знаний и экспертные системы

![Сводка по символическому ИИ](../../../../translated_images/ai-symbolic.715a30cb610411a6964d2e2f23f24364cb338a07cb4844c1f97084d366e586c3.ru.png)

> Скетчноут от [Tomomi Imura](https://twitter.com/girlie_mac)

Поиск искусственного интеллекта основан на стремлении к знаниям, чтобы понимать мир так же, как это делают люди. Но как это можно осуществить?

## [Тест перед лекцией](https://ff-quizzes.netlify.app/en/ai/quiz/3)

В первые дни развития ИИ популярным был подход сверху вниз к созданию интеллектуальных систем (обсуждался в предыдущем уроке). Идея заключалась в том, чтобы извлечь знания от людей в машиночитаемую форму, а затем использовать их для автоматического решения задач. Этот подход основывался на двух ключевых идеях:

* Представление знаний
* Рассуждение

## Представление знаний

Одним из важных понятий в символическом ИИ являются **знания**. Важно отличать знания от *информации* или *данных*. Например, можно сказать, что книги содержат знания, потому что изучая их, можно стать экспертом. Однако то, что содержится в книгах, на самом деле называется *данными*, и, читая книги и интегрируя эти данные в нашу модель мира, мы превращаем данные в знания.

> ✅ **Знания** — это то, что содержится в нашей голове и представляет наше понимание мира. Они приобретаются в процессе активного **обучения**, который интегрирует полученную информацию в нашу активную модель мира.

Чаще всего мы не даем строгого определения знаниям, но связываем их с другими близкими понятиями, используя [пирамиду DIKW](https://en.wikipedia.org/wiki/DIKW_pyramid). Она включает следующие понятия:

* **Данные** — это то, что представлено на физическом носителе, например, в виде текста или устной речи. Данные существуют независимо от человека и могут передаваться между людьми.
* **Информация** — это то, как мы интерпретируем данные в своей голове. Например, когда мы слышим слово *компьютер*, у нас есть некоторое представление о том, что это такое.
* **Знания** — это информация, интегрированная в нашу модель мира. Например, изучив, что такое компьютер, мы начинаем понимать, как он работает, сколько он стоит и для чего его можно использовать. Эта сеть взаимосвязанных понятий формирует наши знания.
* **Мудрость** — это еще один уровень нашего понимания мира, который представляет собой *метазнания*, например, представление о том, как и когда следует использовать знания.

<img src="images/DIKW_Pyramid.png" width="30%"/>

*Изображение [из Википедии](https://commons.wikimedia.org/w/index.php?curid=37705247), By Longlivetheux - Own work, CC BY-SA 4.0*

Таким образом, задача **представления знаний** заключается в поиске эффективного способа представления знаний внутри компьютера в виде данных, чтобы они могли быть использованы автоматически. Это можно рассматривать как спектр:

![Спектр представления знаний](../../../../translated_images/knowledge-spectrum.b60df631852c0217e941485b79c9eee40ebd574f15f18609cec5758fcb384bf3.ru.png)

> Изображение от [Dmitry Soshnikov](http://soshnikov.com)

* Слева находятся очень простые типы представления знаний, которые могут быть эффективно использованы компьютерами. Самый простой — алгоритмический, когда знания представлены в виде компьютерной программы. Однако это не лучший способ представления знаний, так как он не гибкий. Знания в нашей голове часто не алгоритмичны.
* Справа находятся представления, такие как естественный текст. Это самый мощный способ, но он не может быть использован для автоматического рассуждения.

> ✅ Подумайте минуту о том, как вы представляете знания в своей голове и переводите их в заметки. Есть ли формат, который помогает вам лучше запоминать?

## Классификация представлений знаний в компьютере

Мы можем классифицировать различные методы представления знаний в компьютере по следующим категориям:

* **Сетевые представления** основаны на том, что в нашей голове есть сеть взаимосвязанных понятий. Мы можем попытаться воспроизвести такие же сети в виде графа внутри компьютера — так называемую **семантическую сеть**.

1. **Триплеты объект-атрибут-значение** или **пары атрибут-значение**. Поскольку граф может быть представлен в компьютере как список узлов и ребер, мы можем представить семантическую сеть в виде списка триплетов, содержащих объекты, атрибуты и значения. Например, мы создаем следующие триплеты о языках программирования:

Объект | Атрибут | Значение
-------|---------|---------
Python | является | Языком без типизации
Python | изобретен | Гвидо ван Россумом
Python | синтаксис блока | отступы
Язык без типизации | не имеет | определения типов

> ✅ Подумайте, как триплеты могут быть использованы для представления других типов знаний.

2. **Иерархические представления** подчеркивают тот факт, что мы часто создаем иерархию объектов в своей голове. Например, мы знаем, что канарейка — это птица, и у всех птиц есть крылья. Мы также имеем представление о том, какого цвета обычно канарейки и какова их скорость полета.

   - **Представление в виде фреймов** основано на представлении каждого объекта или класса объектов в виде **фрейма**, который содержит **слоты**. Слоты могут иметь возможные значения по умолчанию, ограничения значений или хранимые процедуры, которые можно вызвать для получения значения слота. Все фреймы образуют иерархию, похожую на иерархию объектов в языках программирования, основанных на объектно-ориентированном подходе.
   - **Сценарии** — это особый вид фреймов, которые представляют сложные ситуации, разворачивающиеся во времени.

**Python**

Слот | Значение | Значение по умолчанию | Интервал |
-----|---------|-----------------------|----------|
Имя | Python | | |
Является | Языком без типизации | | |
Регистр переменных | | CamelCase | |
Длина программы | | | 5-5000 строк |
Синтаксис блока | Отступ | | |

3. **Процедурные представления** основаны на представлении знаний в виде списка действий, которые могут быть выполнены при возникновении определенного условия.
   - Правила продукций — это конструкции вида "если-то", которые позволяют делать выводы. Например, у врача может быть правило, гласящее, что **ЕСЛИ** у пациента высокая температура **ИЛИ** высокий уровень С-реактивного белка в анализе крови, **ТО** у него воспаление. Как только мы сталкиваемся с одним из условий, мы можем сделать вывод о воспалении, а затем использовать его для дальнейших рассуждений.
   - Алгоритмы можно считать другой формой процедурного представления, хотя они почти никогда не используются напрямую в системах, основанных на знаниях.

4. **Логика** была изначально предложена Аристотелем как способ представления универсальных человеческих знаний.
   - Логика предикатов как математическая теория слишком богата, чтобы быть вычислимой, поэтому обычно используется ее подмножество, например, Хорновы клаузы, применяемые в Prolog.
   - Описательная логика — это семейство логических систем, используемых для представления и рассуждения о иерархиях объектов и распределенных представлениях знаний, таких как *семантическая сеть*.

## Экспертные системы

Одним из ранних успехов символического ИИ стали так называемые **экспертные системы** — компьютерные системы, разработанные для выполнения роли эксперта в ограниченной области задач. Они основывались на **базе знаний**, извлеченной от одного или нескольких человеческих экспертов, и содержали **выводящий механизм**, который выполнял рассуждения на ее основе.

![Архитектура человека](../../../../translated_images/arch-human.5d4d35f1bba3ab1cdfda96af2f10b89574eb31e9796d0e3011cd9beda1c35112.ru.png) | ![Система на основе знаний](../../../../translated_images/arch-kbs.3ec5c150b09fa8dadc2beb0931a4983c9e2b03913a89eebcc103b5bb841b0212.ru.png)
---------------------------------------------|------------------------------------------------
Упрощенная структура нейронной системы человека | Архитектура системы на основе знаний

Экспертные системы строятся подобно системе рассуждений человека, которая содержит **кратковременную память** и **долговременную память**. Аналогично, в системах на основе знаний выделяются следующие компоненты:

* **Память задачи**: содержит знания о задаче, которая в данный момент решается, например, температура или давление пациента, есть ли у него воспаление и т.д. Эти знания также называются **статическими знаниями**, так как они представляют собой снимок того, что мы знаем о задаче в данный момент — так называемое *состояние задачи*.
* **База знаний**: представляет собой долговременные знания о предметной области. Она извлекается вручную от человеческих экспертов и не изменяется от консультации к консультации. Поскольку она позволяет переходить от одного состояния задачи к другому, ее также называют **динамическими знаниями**.
* **Выводящий механизм**: организует весь процесс поиска в пространстве состояний задачи, задавая вопросы пользователю, когда это необходимо. Он также отвечает за поиск подходящих правил для применения к каждому состоянию.

В качестве примера рассмотрим следующую экспертную систему для определения животного на основе его физических характеристик:

![AND-OR дерево](../../../../translated_images/AND-OR-Tree.5592d2c70187f283703c8e9c0d69d6a786eb370f4ace67f9a7aae5ada3d260b0.ru.png)

> Изображение от [Dmitry Soshnikov](http://soshnikov.com)

Эта диаграмма называется **AND-OR деревом**, и она представляет собой графическое отображение набора правил продукций. Рисование дерева полезно на начальном этапе извлечения знаний от эксперта. Для представления знаний внутри компьютера удобнее использовать правила:

```
IF the animal eats meat
OR (animal has sharp teeth
    AND animal has claws
    AND animal has forward-looking eyes
) 
THEN the animal is a carnivore
```

Вы можете заметить, что каждое условие в левой части правила и действие фактически являются триплетами объект-атрибут-значение (OAV). **Рабочая память** содержит набор триплетов OAV, соответствующих задаче, которая в данный момент решается. **Механизм правил** ищет правила, для которых условие выполнено, и применяет их, добавляя новый триплет в рабочую память.

> ✅ Нарисуйте свое собственное AND-OR дерево на тему, которая вам интересна!

### Прямой и обратный вывод

Процесс, описанный выше, называется **прямым выводом**. Он начинается с некоторой начальной информации о задаче, доступной в рабочей памяти, и затем выполняет следующий цикл рассуждений:

1. Если целевой атрибут присутствует в рабочей памяти — остановиться и выдать результат.
2. Найти все правила, условия которых в данный момент выполнены — получить **конфликтный набор** правил.
3. Выполнить **разрешение конфликта** — выбрать одно правило, которое будет выполнено на этом шаге. Существуют разные стратегии разрешения конфликта:
   - Выбрать первое применимое правило в базе знаний.
   - Выбрать случайное правило.
   - Выбрать *более специфичное* правило, то есть то, которое удовлетворяет наибольшему числу условий в левой части (LHS).
4. Применить выбранное правило и вставить новый кусок знаний в состояние задачи.
5. Повторить с шага 1.

Однако в некоторых случаях мы можем захотеть начать с пустых знаний о задаче и задавать вопросы, которые помогут нам прийти к выводу. Например, при медицинской диагностике мы обычно не проводим все медицинские анализы заранее, прежде чем начать диагностику пациента. Мы скорее хотим проводить анализы, когда нужно принять решение.

Этот процесс можно смоделировать с помощью **обратного вывода**. Он управляется **целью** — значением атрибута, которое мы пытаемся найти:

1. Выбрать все правила, которые могут дать нам значение цели (то есть с целью в правой части (RHS)) — конфликтный набор.
1. Если для этого атрибута нет правил или есть правило, говорящее, что значение следует спросить у пользователя — спросить его, иначе:
1. Использовать стратегию разрешения конфликта, чтобы выбрать одно правило, которое мы будем использовать как *гипотезу* — мы попробуем доказать его.
1. Рекурсивно повторить процесс для всех атрибутов в левой части правила, пытаясь доказать их как цели.
1. Если в какой-то момент процесс терпит неудачу — использовать другое правило на шаге 3.

> ✅ В каких ситуациях прямой вывод более уместен? А как насчет обратного вывода?

### Реализация экспертных систем

Экспертные системы могут быть реализованы с использованием различных инструментов:

* Программирование их напрямую на каком-либо языке высокого уровня. Это не лучший вариант, так как главное преимущество системы на основе знаний заключается в том, что знания отделены от вывода, и потенциально эксперт в предметной области должен иметь возможность писать правила, не понимая деталей процесса вывода.
* Использование **оболочки экспертной системы**, то есть системы, специально разработанной для заполнения знаниями с использованием языка представления знаний.

## ✍️ Упражнение: вывод о животных

См. [Animals.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/Animals.ipynb) для примера реализации экспертной системы с прямым и обратным выводом.

> **Примечание**: Этот пример довольно прост и лишь дает представление о том, как выглядит экспертная система. Как только вы начнете создавать такую систему, вы заметите некоторое *интеллектуальное* поведение только после достижения определенного количества правил, около 200+. В какой-то момент правила становятся слишком сложными, чтобы держать их все в голове, и в этот момент вы можете начать задаваться вопросом, почему система принимает определенные решения. Однако важной характеристикой систем на основе знаний является то, что вы всегда можете *объяснить*, как было принято любое из решений.

## Онтологии и семантическая сеть

В конце XX века была инициатива использовать представление знаний для аннотирования интернет-ресурсов, чтобы можно было находить ресурсы, соответствующие очень специфическим запросам. Это движение называлось **семантической сетью**, и оно опиралось на несколько концепций:

- Специальное представление знаний, основанное на **[описательной логике](https://en.wikipedia.org/wiki/Description_logic)** (DL). Оно похоже на представление знаний в виде фреймов, так как строит иерархию объектов с их свойствами, но имеет формальную логическую семантику и вывод. Существует целое семейство DL, которые балансируют между выразительностью и алгоритмической сложностью вывода.
- Распределенное представление знаний, где все понятия представлены глобальным идентификатором URI, что делает возможным создание иерархий знаний, охватывающих интернет.
- Семейство языков на основе XML для описания знаний: RDF (Resource Description Framework), RDFS (RDF Schema), OWL (Ontology Web Language).

Основное понятие в Семантической сети — это **Онтология**. Она представляет собой явное описание предметной области с использованием формального представления знаний. Самая простая онтология может быть просто иерархией объектов в предметной области, но более сложные онтологии включают правила, которые можно использовать для вывода.

В семантической сети все представления основаны на триплетах. Каждый объект и каждая связь уникально идентифицируются с помощью URI. Например, если мы хотим указать факт, что этот учебный курс по искусственному интеллекту был разработан Дмитрием Сошниковым 1 января 2022 года, вот триплеты, которые мы можем использовать:

<img src="images/triplet.png" width="30%"/>

```
http://github.com/microsoft/ai-for-beginners http://www.example.com/terms/creation-date “Jan 13, 2007”
http://github.com/microsoft/ai-for-beginners http://purl.org/dc/elements/1.1/creator http://soshnikov.com
```

> ✅ Здесь `http://www.example.com/terms/creation-date` и `http://purl.org/dc/elements/1.1/creator` — это известные и общепринятые URI для выражения понятий *создатель* и *дата создания*.

В более сложном случае, если мы хотим определить список создателей, мы можем использовать некоторые структуры данных, определенные в RDF.

<img src="images/triplet-complex.png" width="40%"/>

> Диаграммы выше созданы [Дмитрием Сошниковым](http://soshnikov.com)

Развитие Семантической сети было несколько замедлено успехом поисковых систем и методов обработки естественного языка, которые позволяют извлекать структурированные данные из текста. Однако в некоторых областях все еще предпринимаются значительные усилия для поддержания онтологий и баз знаний. Несколько проектов, заслуживающих внимания:

* [WikiData](https://wikidata.org/) — это коллекция машиночитаемых баз знаний, связанных с Википедией. Большая часть данных извлекается из *InfoBoxes* Википедии — структурированных элементов контента внутри страниц Википедии. Вы можете [запросить](https://query.wikidata.org/) данные WikiData с помощью SPARQL, специального языка запросов для Семантической сети. Вот пример запроса, который отображает самые популярные цвета глаз среди людей:

```sparql
#defaultView:BubbleChart
SELECT ?eyeColorLabel (COUNT(?human) AS ?count)
WHERE
{
  ?human wdt:P31 wd:Q5.       # human instance-of homo sapiens
  ?human wdt:P1340 ?eyeColor. # human eye-color ?eyeColor
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
GROUP BY ?eyeColorLabel
```

* [DBpedia](https://www.dbpedia.org/) — еще один проект, похожий на WikiData.

> ✅ Если вы хотите поэкспериментировать с созданием собственных онтологий или изучением существующих, есть отличный визуальный редактор онтологий [Protégé](https://protege.stanford.edu/). Скачайте его или используйте онлайн.

<img src="images/protege.png" width="70%"/>

*Веб-редактор Protégé открыт с онтологией семьи Романовых. Скриншот Дмитрия Сошникова*

## ✍️ Упражнение: Онтология семьи

Смотрите [FamilyOntology.ipynb](https://github.com/Ezana135/AI-For-Beginners/blob/main/lessons/2-Symbolic/FamilyOntology.ipynb) для примера использования методов Семантической сети для анализа семейных отношений. Мы возьмем генеалогическое дерево, представленное в формате GEDCOM, и онтологию семейных отношений, чтобы построить граф всех семейных связей для заданного набора людей.

## Microsoft Concept Graph

В большинстве случаев онтологии создаются вручную. Однако также возможно **извлекать** онтологии из неструктурированных данных, например, из текстов на естественном языке.

Один из таких проектов был реализован Microsoft Research и привел к созданию [Microsoft Concept Graph](https://blogs.microsoft.com/ai/microsoft-researchers-release-graph-that-helps-machines-conceptualize/?WT.mc_id=academic-77998-cacaste).

Это большая коллекция сущностей, сгруппированных с использованием отношения наследования `is-a`. Она позволяет отвечать на вопросы вроде "Что такое Microsoft?" — ответ будет что-то вроде "компания с вероятностью 0.87 и бренд с вероятностью 0.75".

Граф доступен либо через REST API, либо в виде большого текстового файла, содержащего все пары сущностей.

## ✍️ Упражнение: Граф концепций

Попробуйте блокнот [MSConceptGraph.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/MSConceptGraph.ipynb), чтобы увидеть, как можно использовать Microsoft Concept Graph для группировки новостных статей по категориям.

## Заключение

Сегодня искусственный интеллект часто ассоциируется с *машинным обучением* или *нейронными сетями*. Однако человек также демонстрирует явное рассуждение, что пока не реализовано в нейронных сетях. В реальных проектах явное рассуждение все еще используется для выполнения задач, требующих объяснений или возможности контролируемо изменять поведение системы.

## 🚀 Задание

В блокноте Family Ontology, связанном с этим уроком, есть возможность поэкспериментировать с другими семейными отношениями. Попробуйте найти новые связи между людьми в генеалогическом дереве.

## [Тест после лекции](https://ff-quizzes.netlify.app/en/ai/quiz/4)

## Обзор и самостоятельное изучение

Исследуйте в интернете области, где люди пытались количественно оценить и систематизировать знания. Ознакомьтесь с таксономией Блума и изучите историю, чтобы узнать, как люди пытались осмыслить окружающий мир. Изучите работу Линнея по созданию таксономии организмов и обратите внимание на то, как Дмитрий Менделеев разработал способ описания и группировки химических элементов. Какие еще интересные примеры вы можете найти?

**Задание**: [Создайте онтологию](assignment.md)

---

