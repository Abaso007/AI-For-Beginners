<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "4bedc8e702db17260cfe824d58b6cfd4",
  "translation_date": "2025-08-26T06:42:22+00:00",
  "source_file": "lessons/4-ComputerVision/06-IntroCV/README.md",
  "language_code": "ru"
}
-->
# Введение в компьютерное зрение

[Компьютерное зрение](https://wikipedia.org/wiki/Computer_vision) — это область, цель которой заключается в том, чтобы научить компьютеры понимать цифровые изображения на высоком уровне. Это довольно широкое определение, поскольку *понимание* может означать множество вещей, включая поиск объекта на изображении (**обнаружение объектов**), понимание происходящего (**обнаружение событий**), описание изображения текстом или реконструкцию сцены в 3D. Существуют также специальные задачи, связанные с изображениями людей: оценка возраста и эмоций, обнаружение и идентификация лиц, а также оценка позы в 3D, чтобы назвать лишь некоторые.

## [Тест перед лекцией](https://ff-quizzes.netlify.app/en/ai/quiz/11)

Одна из самых простых задач компьютерного зрения — это **классификация изображений**.

Компьютерное зрение часто рассматривается как ветвь искусственного интеллекта. Сегодня большинство задач компьютерного зрения решаются с использованием нейронных сетей. Мы подробнее изучим специальный тип нейронных сетей, используемых для компьютерного зрения, [сверточные нейронные сети](../07-ConvNets/README.md), в этом разделе.

Однако, прежде чем передать изображение нейронной сети, во многих случаях имеет смысл использовать некоторые алгоритмические методы для улучшения изображения.

Существует несколько библиотек Python для обработки изображений:

* **[imageio](https://imageio.readthedocs.io/en/stable/)** используется для чтения/записи различных форматов изображений. Она также поддерживает ffmpeg — полезный инструмент для преобразования видеокадров в изображения.
* **[Pillow](https://pillow.readthedocs.io/en/stable/index.html)** (также известная как PIL) обладает большими возможностями и поддерживает манипуляции с изображениями, такие как морфинг, настройка палитры и многое другое.
* **[OpenCV](https://opencv.org/)** — мощная библиотека обработки изображений, написанная на C++, которая стала стандартом *де факто* для обработки изображений. Она имеет удобный интерфейс для Python.
* **[dlib](http://dlib.net/)** — библиотека на C++, реализующая множество алгоритмов машинного обучения, включая некоторые алгоритмы компьютерного зрения. Она также имеет интерфейс для Python и может использоваться для сложных задач, таких как обнаружение лиц и ключевых точек лица.

## OpenCV

[OpenCV](https://opencv.org/) считается стандартом *де факто* для обработки изображений. Она содержит множество полезных алгоритмов, реализованных на C++. Вы также можете использовать OpenCV из Python.

Хорошее место для изучения OpenCV — [курс Learn OpenCV](https://learnopencv.com/getting-started-with-opencv/). В рамках нашей программы мы не ставим целью изучение OpenCV, а хотим показать несколько примеров, где она может быть полезна и как ее использовать.

### Загрузка изображений

Изображения в Python удобно представлять в виде массивов NumPy. Например, черно-белые изображения размером 320x200 пикселей будут храниться в массиве размером 200x320, а цветные изображения тех же размеров будут иметь форму 200x320x3 (для трех цветовых каналов). Чтобы загрузить изображение, можно использовать следующий код:

```python
import cv2
import matplotlib.pyplot as plt

im = cv2.imread('image.jpeg')
plt.imshow(im)
```

Традиционно OpenCV использует кодировку BGR (синий-зеленый-красный) для цветных изображений, тогда как остальные инструменты Python используют более привычную RGB (красный-зеленый-синий). Чтобы изображение отображалось правильно, его нужно преобразовать в цветовое пространство RGB, либо поменяв местами измерения в массиве NumPy, либо вызвав функцию OpenCV:

```python
im = cv2.cvtColor(im,cv2.COLOR_BGR2RGB)
```

Та же функция `cvtColor` может использоваться для выполнения других преобразований цветового пространства, таких как преобразование изображения в черно-белое или в HSV (оттенок-насыщенность-яркость).

Вы также можете использовать OpenCV для загрузки видео покадрово — пример приведен в упражнении [OpenCV Notebook](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb).

### Обработка изображений

Перед передачей изображения нейронной сети может быть полезно выполнить несколько шагов предварительной обработки. OpenCV позволяет делать множество вещей, включая:

* **Изменение размера** изображения с помощью `im = cv2.resize(im, (320,200),interpolation=cv2.INTER_LANCZOS)`
* **Размытие** изображения с помощью `im = cv2.medianBlur(im,3)` или `im = cv2.GaussianBlur(im, (3,3), 0)`
* Изменение **яркости и контрастности** изображения можно выполнить с помощью манипуляций с массивами NumPy, как описано [в этой заметке на Stackoverflow](https://stackoverflow.com/questions/39308030/how-do-i-increase-the-contrast-of-an-image-in-python-opencv).
* Использование [пороговой обработки](https://docs.opencv.org/4.x/d7/d4d/tutorial_py_thresholding.html) с помощью функций `cv2.threshold`/`cv2.adaptiveThreshold`, что часто предпочтительнее, чем настройка яркости или контрастности.
* Применение различных [преобразований](https://docs.opencv.org/4.5.5/da/d6e/tutorial_py_geometric_transformations.html) к изображению:
    - **[Афинные преобразования](https://docs.opencv.org/4.5.5/d4/d61/tutorial_warp_affine.html)** могут быть полезны, если нужно объединить вращение, изменение размера и наклон изображения, и известны исходное и целевое расположение трех точек на изображении. Афинные преобразования сохраняют параллельность линий.
    - **[Перспективные преобразования](https://medium.com/analytics-vidhya/opencv-perspective-transformation-9edffefb2143)** могут быть полезны, если известны исходные и целевые позиции четырех точек на изображении. Например, если вы сделали снимок прямоугольного документа с помощью камеры смартфона под углом и хотите получить прямоугольное изображение самого документа.
* Понимание движения внутри изображения с помощью **[оптического потока](https://docs.opencv.org/4.5.5/d4/dee/tutorial_optical_flow.html)**.

## Примеры использования компьютерного зрения

В нашем [OpenCV Notebook](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb) мы приводим несколько примеров, когда компьютерное зрение может быть использовано для выполнения конкретных задач:

* **Предварительная обработка фотографии книги на шрифте Брайля**. Мы сосредотачиваемся на том, как можно использовать пороговую обработку, обнаружение признаков, перспективное преобразование и манипуляции с NumPy для разделения отдельных символов шрифта Брайля для дальнейшей классификации нейронной сетью.

![Изображение шрифта Брайля](../../../../../translated_images/braille.341962ff76b1bd7044409371d3de09ced5028132aef97344ea4b7468c1208126.ru.jpeg) | ![Предварительно обработанное изображение шрифта Брайля](../../../../../translated_images/braille-result.46530fea020b03c76aac532d7d6eeef7f6fb35b55b1001cd21627907dabef3ed.ru.png) | ![Символы шрифта Брайля](../../../../../translated_images/braille-symbols.0159185ab69d533909dc4d7d26a1971b51401c6a80eb3a5584f250ea880af88b.ru.png)
----|-----|-----

> Изображение из [OpenCV.ipynb](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb)

* **Обнаружение движения в видео с помощью разницы кадров**. Если камера неподвижна, то кадры из видеопотока должны быть довольно похожи друг на друга. Поскольку кадры представлены в виде массивов, просто вычитая эти массивы для двух последовательных кадров, мы получим разницу пикселей, которая должна быть низкой для статичных кадров и становиться выше при значительном движении на изображении.

![Изображение видеокадров и разницы кадров](../../../../../translated_images/frame-difference.706f805491a0883c938e16447bf5eb2f7d69e812c7f743cbe7d7c7645168f81f.ru.png)

> Изображение из [OpenCV.ipynb](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb)

* **Обнаружение движения с помощью оптического потока**. [Оптический поток](https://docs.opencv.org/3.4/d4/dee/tutorial_optical_flow.html) позволяет понять, как отдельные пиксели на видеокадрах перемещаются. Существует два типа оптического потока:

   - **Плотный оптический поток** вычисляет векторное поле, показывающее, куда движется каждый пиксель.
   - **Разреженный оптический поток** основан на выделении некоторых характерных признаков изображения (например, краев) и построении их траектории от кадра к кадру.

![Изображение оптического потока](../../../../../translated_images/optical.1f4a94464579a83a10784f3c07fe7228514714b96782edf50e70ccd59d2d8c4f.ru.png)

> Изображение из [OpenCV.ipynb](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb)

## ✍️ Примерные ноутбуки: OpenCV [попробуйте OpenCV в действии](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb)

Давайте проведем эксперименты с OpenCV, изучая [OpenCV Notebook](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb).

## Заключение

Иногда относительно сложные задачи, такие как обнаружение движения или обнаружение кончиков пальцев, могут быть решены исключительно с помощью компьютерного зрения. Поэтому очень полезно знать основные техники компьютерного зрения и возможности таких библиотек, как OpenCV.

## 🚀 Задание

Посмотрите [это видео](https://docs.microsoft.com/shows/ai-show/ai-show--2021-opencv-ai-competition--grand-prize-winners--cortic-tigers--episode-32?WT.mc_id=academic-77998-cacaste) из AI Show, чтобы узнать о проекте Cortic Tigers и о том, как они создали решение на основе блоков для демократизации задач компьютерного зрения с помощью робота. Проведите исследование других подобных проектов, которые помогают новичкам освоить эту область.

## [Тест после лекции](https://ff-quizzes.netlify.app/en/ai/quiz/12)

## Обзор и самостоятельное изучение

Прочитайте больше об оптическом потоке [в этом отличном руководстве](https://learnopencv.com/optical-flow-in-opencv/).

## [Задание](lab/README.md)

В этой лабораторной работе вам нужно будет снять видео с простыми жестами, и ваша цель — извлечь движения вверх/вниз/влево/вправо с помощью оптического потока.

<img src="images/palm-movement.png" width="30%" alt="Кадр движения ладони"/>

**Отказ от ответственности**:  
Этот документ был переведен с использованием сервиса автоматического перевода [Co-op Translator](https://github.com/Azure/co-op-translator). Хотя мы стремимся к точности, пожалуйста, учитывайте, что автоматические переводы могут содержать ошибки или неточности. Оригинальный документ на его родном языке следует считать авторитетным источником. Для получения критически важной информации рекомендуется профессиональный перевод человеком. Мы не несем ответственности за любые недоразумения или неправильные интерпретации, возникающие в результате использования данного перевода.