<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "7d097f7fda9166ead615e4c34552381b",
  "translation_date": "2025-10-11T11:35:50+00:00",
  "source_file": "lessons/2-Symbolic/README.md",
  "language_code": "ta"
}
-->
# அறிவு பிரதிநிதித்துவம் மற்றும் நிபுணர் அமைப்புகள்

![சின்னவியல் AI உள்ளடக்கத்தின் சுருக்கம்](../../../../translated_images/ai-symbolic.715a30cb610411a6964d2e2f23f24364cb338a07cb4844c1f97084d366e586c3.ta.png)

> [Tomomi Imura](https://twitter.com/girlie_mac) அவர்களின் சின்னவியல் குறிப்பு

மனிதர்கள் உலகத்தை புரிந்து கொள்ளும் முறையைப் போலவே, செயற்கை நுண்ணறிவை உருவாக்கும் தேடல் அறிவைத் தேடுவதில் அடிப்படையாக உள்ளது. ஆனால், இதை எவ்வாறு செய்ய முடியும்?

## [முன்-வகுப்பு வினாடி வினா](https://ff-quizzes.netlify.app/en/ai/quiz/3)

AI-யின் ஆரம்ப காலங்களில், புத்திசாலி அமைப்புகளை உருவாக்குவதற்கான மேல்-கீழ் அணுகுமுறை (முந்தைய பாடத்தில் விவாதிக்கப்பட்டது) பிரபலமாக இருந்தது. இந்த அணுகுமுறை இரண்டு முக்கிய கருத்துக்களை அடிப்படையாகக் கொண்டது:

* அறிவு பிரதிநிதித்துவம்
* காரணம்

## அறிவு பிரதிநிதித்துவம்

சின்னவியல் AI-யில் முக்கியமான கருத்துகளில் ஒன்று **அறிவு**. *தகவல்* அல்லது *தரவு* என்பதிலிருந்து அறிவை வேறுபடுத்துவது முக்கியம். உதாரணமாக, புத்தகங்கள் அறிவை உள்ளடக்கியவை என்று கூறலாம், ஏனெனில் புத்தகங்களைப் படித்து நிபுணராக மாறலாம். ஆனால், புத்தகங்களில் உள்ளவை உண்மையில் *தரவு* என்று அழைக்கப்படுகிறது, மேலும் புத்தகங்களைப் படித்து, இந்த தரவுகளை நமது உலக மாதிரியில் ஒருங்கிணைப்பதன் மூலம், இந்த தரவை அறிவாக மாற்றுகிறோம்.

> ✅ **அறிவு** என்பது நமது தலையில் உள்ளதொன்றாகும், மேலும் அது உலகத்தைப் பற்றிய நமது புரிதலை பிரதிநிதித்துவப்படுத்துகிறது. இது ஒரு செயலில் **கற்றல்** செயல்முறையால் பெறப்படுகிறது, இது நாங்கள் பெறும் தகவல்களின் துண்டுகளை நமது உலக மாதிரியில் ஒருங்கிணைக்கிறது.

அறிவை நாங்கள் பெரும்பாலும் கடுமையாக வரையறுக்கவில்லை, ஆனால் அதை [DIKW Pyramid](https://en.wikipedia.org/wiki/DIKW_pyramid) மூலம் தொடர்புடைய கருத்துகளுடன் இணைக்கிறோம். இது பின்வரும் கருத்துக்களை உள்ளடக்கியது:

* **தரவு** என்பது எழுதப்பட்ட உரை அல்லது பேசப்பட்ட வார்த்தைகள் போன்ற உடல் ஊடகங்களில் பிரதிநிதித்துவப்படுத்தப்படும் ஒன்றாகும். தரவு மனிதர்களிடமிருந்து சுயாதீனமாக உள்ளது மற்றும் மனிதர்களுக்கு இடையே பரிமாறப்படலாம்.
* **தகவல்** என்பது நாங்கள் நமது தலையில் தரவை எப்படி விளக்குகிறோம் என்பதைக் குறிக்கிறது. உதாரணமாக, *கணினி* என்ற வார்த்தையை நாம் கேட்கும்போது, அது என்ன என்பதைப் பற்றிய சில புரிதல்கள் நமக்கு உள்ளன.
* **அறிவு** என்பது தகவலை நமது உலக மாதிரியில் ஒருங்கிணைப்பதாகும். உதாரணமாக, ஒரு கணினி என்ன என்பதை நாங்கள் கற்றுக்கொண்ட பிறகு, அது எப்படி செயல்படுகிறது, அதன் விலை எவ்வளவு, மற்றும் அது எதற்காக பயன்படுத்தப்படலாம் என்பதற்கான சில கருத்துக்கள் நமக்கு உருவாகின்றன. இந்த தொடர்புடைய கருத்துக்களின் வலை நமது அறிவை உருவாக்குகிறது.
* **ஞானம்** என்பது உலகத்தைப் பற்றிய நமது புரிதலின் மேலும் ஒரு நிலையாகும், மேலும் இது *மெட்டா-அறிவை* பிரதிநிதித்துவப்படுத்துகிறது, உதாரணமாக, அறிவு எப்போது மற்றும் எப்படி பயன்படுத்தப்பட வேண்டும் என்பதற்கான கருத்து.

<img src="../../../../translated_images/DIKW_Pyramid.94126f7d2bd8db5be71c6f1658b94bd3c85342e3cb827913b556b0414d358340.ta.png" width="30%"/>

*படம் [விக்கிப்பீடியாவில் இருந்து](https://commons.wikimedia.org/w/index.php?curid=37705247), Longlivetheux - சொந்த வேலை, CC BY-SA 4.0*

அதனால், **அறிவு பிரதிநிதித்துவம்** என்ற பிரச்சினை என்பது கணினியில் தரவின் வடிவத்தில் அறிவை பிரதிநிதித்துவப்படுத்துவதற்கான சில பயனுள்ள வழிகளை கண்டுபிடிப்பதாகும், இதை தானாகவே பயன்படுத்த முடியும். இது ஒரு வரம்பாகக் காணப்படுகிறது:

![அறிவு பிரதிநிதித்துவ வரம்பு](../../../../translated_images/knowledge-spectrum.b60df631852c0217e941485b79c9eee40ebd574f15f18609cec5758fcb384bf3.ta.png)

> [Dmitry Soshnikov](http://soshnikov.com) அவர்களின் படங்கள்

* இடதுபுறத்தில், கணினிகள் மூலம் பயனுள்ளதாக பயன்படுத்தக்கூடிய மிகவும் எளிய வகையான அறிவு பிரதிநிதித்துவங்கள் உள்ளன. மிகவும் எளிமையானது ஒரு கணினி நிரலால் பிரதிநிதித்துவப்படுத்தப்படும் அல்காரிதமிக் அறிவு. இது, எனினும், அறிவை பிரதிநிதித்துவப்படுத்துவதற்கான சிறந்த வழி அல்ல, ஏனெனில் இது நெகிழ்வானது அல்ல. நமது தலையில் உள்ள அறிவு பெரும்பாலும் அல்காரிதமிக் அல்ல.
* வலதுபுறத்தில், இயற்கை உரை போன்ற பிரதிநிதித்துவங்கள் உள்ளன. இது மிகவும் சக்திவாய்ந்தது, ஆனால் தானாகவே காரணம் காண்பதற்கு பயன்படுத்த முடியாது.

> ✅ உங்கள் தலையில் அறிவை எப்படி பிரதிநிதித்துவப்படுத்துகிறீர்கள் மற்றும் அதை குறிப்புகளாக மாற்றுகிறீர்கள் என்பதை ஒரு நிமிடம் யோசிக்கவும். உங்கள் நினைவில் வைத்துக்கொள்ள உதவுவதற்கான ஒரு குறிப்பிட்ட வடிவம் உங்களுக்கு வேலை செய்கிறதா?

## கணினி அறிவு பிரதிநிதித்துவங்களை வகைப்படுத்துதல்

கணினி அறிவு பிரதிநிதித்துவ முறைகளை பின்வரும் வகைகளில் வகைப்படுத்தலாம்:

* **வலை பிரதிநிதித்துவங்கள்** நமது தலையில் தொடர்புடைய கருத்துக்களின் வலை உள்ளது என்பதை அடிப்படையாகக் கொண்டவை. நாங்கள் அதே வலைகளை ஒரு **semantic network** எனக் கணினியில் ஒரு கிராஃப் ஆக மீண்டும் உருவாக்க முயற்சிக்கலாம்.

1. **வஸ்து-அடிப்படை-மதிப்பு மூன்றெடுப்புகள்** அல்லது **அடிப்படை-மதிப்பு ஜோடிகள்**. ஒரு கிராஃப் கணினியில் நொடுகள் மற்றும் விளிம்புகளின் பட்டியலாக பிரதிநிதித்துவப்படுத்தப்படலாம், எனவே ஒரு semantic network ஐ மூன்றெடுப்புகளின் பட்டியலாக பிரதிநிதித்துவப்படுத்தலாம், இதில் பொருட்கள், அடிப்படைகள் மற்றும் மதிப்புகள் உள்ளன. உதாரணமாக, நிரலாக்க மொழிகள் பற்றிய பின்வரும் மூன்றெடுப்புகளை நாங்கள் உருவாக்குகிறோம்:

Object | Attribute | Value
-------|-----------|------
Python | is | Untyped-Language
Python | invented-by | Guido van Rossum
Python | block-syntax | indentation
Untyped-Language | doesn't have | type definitions

> ✅ மூன்றெடுப்புகள் மற்ற வகையான அறிவை பிரதிநிதித்துவப்படுத்த எப்படி பயன்படுத்தப்படலாம் என்று யோசிக்கவும்.

2. **அடுக்கு பிரதிநிதித்துவங்கள்** நாங்கள் நமது தலையில் பொருட்களின் ஒரு அடுக்கை உருவாக்குகிறோம் என்பதை வலியுறுத்துகின்றன. உதாரணமாக, நாங்கள் கானரி ஒரு பறவை என்று அறிகிறோம், மேலும் அனைத்து பறவைகளுக்கும் இறகுகள் உள்ளன. மேலும், கானரியின் நிறம் மற்றும் அதன் பறக்கும் வேகம் பற்றிய சில கருத்துக்கள் நமக்கு உள்ளன.

   - **Frame representation** என்பது ஒவ்வொரு பொருள் அல்லது பொருட்களின் வகுப்பையும் **frame** ஆக பிரதிநிதித்துவப்படுத்துவதில் அடிப்படையாக உள்ளது, இது **slots** ஐ கொண்டுள்ளது. Slots க்கு இயல்புநிலை மதிப்புகள், மதிப்பு கட்டுப்பாடுகள் அல்லது ஒரு slot இன் மதிப்பை பெற அழைக்கக்கூடிய சேமிக்கப்பட்ட செயல்முறைகள் இருக்கலாம். அனைத்து frames க்கும் object-oriented programming மொழிகளில் object hierarchy போன்ற ஒரு hierarchy உள்ளது.
   - **Scenarios** என்பது நேரத்தில் unfold ஆகக்கூடிய சிக்கலான சூழல்களை பிரதிநிதித்துவப்படுத்தும் frames இன் ஒரு சிறப்பு வகை.

**Python**

Slot | Value | Default value | Interval |
-----|-------|---------------|----------|
Name | Python | | |
Is-A | Untyped-Language | | |
Variable Case | | CamelCase | |
Program Length | | | 5-5000 lines |
Block Syntax | Indent | | |

3. **செயல்முறை பிரதிநிதித்துவங்கள்** என்பது ஒரு குறிப்பிட்ட நிலை ஏற்படும் போது செயல்படுத்தக்கூடிய செயல்களின் பட்டியலால் அறிவை பிரதிநிதித்துவப்படுத்துவதில் அடிப்படையாக உள்ளது.
   - **Production rules** என்பது முடிவுகளை வரையறுக்க அனுமதிக்கும் if-then அறிக்கைகள். உதாரணமாக, ஒரு மருத்துவர் **IF** ஒரு நோயாளிக்கு அதிக காய்ச்சல் **OR** இரத்த பரிசோதனையில் அதிக அளவிலான C-reactive protein இருந்தால் **THEN** அவருக்கு ஒரு அழற்சி உள்ளது என்று கூறும் ஒரு விதியை வைத்திருக்கலாம். நாங்கள் ஒரு நிலையை சந்திக்கும் போது, ​​அழற்சியைப் பற்றிய ஒரு முடிவை எடுக்க முடியும், பின்னர் அதை மேலும் காரணம் காண்பதற்குப் பயன்படுத்தலாம்.
   - **Algorithms** என்பது அறிவு அடிப்படையிலான அமைப்புகளில் நேரடியாகப் பயன்படுத்தப்படுவதில்லை என்றாலும், மற்றொரு வகையான செயல்முறை பிரதிநிதித்துவமாகக் கருதப்படலாம்.

4. **Logic** என்பது மனிதர்களின் உலகளாவிய அறிவை பிரதிநிதித்துவப்படுத்தும் ஒரு வழியாக அரிஸ்டாட்டில் மூலம் முதலில் முன்மொழியப்பட்டது.
   - **Predicate Logic** என்பது கணித கோட்பாடாக கணினி செயல்பட முடியாத அளவுக்கு செறிவாக உள்ளது, எனவே பொதுவாக அதன் ஒரு subset மட்டுமே பயன்படுத்தப்படுகிறது, உதாரணமாக Prolog இல் பயன்படுத்தப்படும் Horn clauses.
   - **Descriptive Logic** என்பது *semantic web* போன்ற விநியோகிக்கப்பட்ட அறிவு பிரதிநிதித்துவங்களைப் பற்றிய hierarchies ஐ பிரதிநிதித்துவப்படுத்த மற்றும் காரணம் காண பயன்படுத்தப்படும் தர்க்க முறைமைகளின் குடும்பமாகும்.

## நிபுணர் அமைப்புகள்

சின்னவியல் AI-யின் ஆரம்ப வெற்றிகளில் ஒன்று **நிபுணர் அமைப்புகள்** - குறிப்பிட்ட பிரச்சினை துறையில் நிபுணராக செயல்பட வடிவமைக்கப்பட்ட கணினி அமைப்புகள். அவை **knowledge base** மற்றும் **inference engine** ஆகியவற்றின் அடிப்படையில் உருவாக்கப்பட்டன.

![மனித அமைப்பு](../../../../translated_images/arch-human.5d4d35f1bba3ab1cdfda96af2f10b89574eb31e9796d0e3011cd9beda1c35112.ta.png) | ![அறிவு அடிப்படையிலான அமைப்பு](../../../../translated_images/arch-kbs.3ec5c150b09fa8dadc2beb0931a4983c9e2b03913a89eebcc103b5bb841b0212.ta.png)
---------------------------------------------|------------------------------------------------
மனித நரம்பு அமைப்பின் எளிமையான அமைப்பு | அறிவு அடிப்படையிலான அமைப்பின் கட்டமைப்பு

நிபுணர் அமைப்புகள் மனித reasoning அமைப்பைப் போலவே கட்டமைக்கப்பட்டுள்ளன, இதில் **short-term memory** மற்றும் **long-term memory** உள்ளது. அதேபோல, அறிவு அடிப்படையிலான அமைப்புகளில் பின்வரும் கூறுகளை வேறுபடுத்துகிறோம்:

* **Problem memory**: தற்போது தீர்க்கப்படும் பிரச்சினை பற்றிய அறிவை உள்ளடக்கியது, அதாவது ஒரு நோயாளியின் வெப்பநிலை அல்லது இரத்த அழுத்தம், அவருக்கு அழற்சி உள்ளதா இல்லையா என்பதற்கான தகவல். இந்த அறிவு **static knowledge** என்றும் அழைக்கப்படுகிறது, ஏனெனில் இது தற்போது பிரச்சினை பற்றிய snapshot ஐ உள்ளடக்கியது - *problem state*.
* **Knowledge base**: ஒரு பிரச்சினை துறையைப் பற்றிய நீண்டகால அறிவை பிரதிநிதித்துவப்படுத்துகிறது. இது மனித நிபுணர்களிடமிருந்து கையேடு மூலம் எடுக்கப்படுகிறது, மேலும் ஆலோசனைக்கு ஆலோசனை மாற்றம் செய்யப்படாது. இது ஒரு problem state இல் இருந்து மற்றொன்றுக்கு செல்ல அனுமதிக்கிறது, எனவே இது **dynamic knowledge** என்றும் அழைக்கப்படுகிறது.
* **Inference engine**: இது problem state space இல் தேடல் செயல்முறையை ஒழுங்குபடுத்துகிறது, தேவையான போது பயனரிடம் கேள்விகள் கேட்கிறது. இது ஒவ்வொரு நிலைக்கு பொருந்தக்கூடிய சரியான விதிகளை கண்டுபிடிப்பதற்கும் பொறுப்பாக உள்ளது.

உதாரணமாக, ஒரு விலங்கின் உடல் பண்புகளை அடிப்படையாகக் கொண்டு அதைத் தீர்மானிக்கும் பின்வரும் நிபுணர் அமைப்பைப் பார்ப்போம்:

![AND-OR Tree](../../../../translated_images/AND-OR-Tree.5592d2c70187f283703c8e9c0d69d6a786eb370f4ace67f9a7aae5ada3d260b0.ta.png)

> [Dmitry Soshnikov](http://soshnikov.com) அவர்களின் படங்கள்

இந்த வரைபடம் **AND-OR tree** என்று அழைக்கப்படுகிறது, மேலும் இது **production rules** இன் ஒரு தொகுப்பின் ஒரு கிராஃபிகல் பிரதிநிதித்துவமாகும். நிபுணரிடமிருந்து அறிவை எடுக்கும் தொடக்கத்தில் ஒரு tree ஐ வரையுவது பயனுள்ளதாக இருக்கும். கணினியில் அறிவை பிரதிநிதித்துவப்படுத்த, விதிகளைப் பயன்படுத்துவது வசதியாக இருக்கும்:

```
IF the animal eats meat
OR (animal has sharp teeth
    AND animal has claws
    AND animal has forward-looking eyes
) 
THEN the animal is a carnivore
```

நீங்கள் கவனிக்கலாம், விதியின் இடது பக்கம் உள்ள ஒவ்வொரு நிலை மற்றும் செயல் அடிப்படையில் **object-attribute-value (OAV) triplets** ஆகும். **Working memory** தற்போதைய பிரச்சினையை தீர்க்கும் OAV triplets க்கான தொகுப்பை உள்ளடக்கியது. **Rules engine** ஒரு நிலை திருப்தி செய்யப்படும் விதிகளைத் தேடுகிறது மற்றும் அவற்றைச் செயல்படுத்துகிறது, மேலும் ஒரு புதிய triplet ஐ working memory இல் சேர்க்கிறது.

> ✅ உங்களுக்கு பிடித்த ஒரு தலைப்பில் உங்கள் சொந்த AND-OR tree ஐ எழுதுங்கள்!

### Forward vs. Backward Inference

மேலே விவரிக்கப்பட்ட செயல்முறை **forward inference** என்று அழைக்கப்படுகிறது. இது working memory இல் கிடைக்கும் பிரச்சினை பற்றிய சில ஆரம்ப தரவுகளுடன் தொடங்குகிறது, பின்னர் பின்வரும் reasoning loop ஐ செயல்படுத்துகிறது:

1. இலக்கு attribute working memory இல் உள்ளதா என்பதைச் சரிபார்க்கவும் - முடித்து முடிவைத் தரவும்
2. தற்போதைய நிலை திருப்தி செய்யப்படும் அனைத்து விதிகளையும் தேடுங்கள் - **conflict set** ஐப் பெறுங்கள்.
3. **Conflict resolution** ஐச் செய்யவும் - இந்த படியில் செயல்படுத்தப்படும் ஒரு விதியைத் தேர்ந்தெடுக்கவும். conflict resolution strategies பலவகையானவை இருக்கலாம்:
   - Knowledge base இல் பொருந்தக்கூடிய முதல் விதியைத் தேர்ந்தெடுக்கவும்
   - ஒரு random விதியைத் தேர்ந்தெடுக்கவும்
   - *மேலும் குறிப்பிட்ட* விதியைத் தேர்ந்தெடுக்கவும், அதாவது "left-hand-side" (LHS) இல் அதிகமான நிலைகளை சந்திக்கும் விதி
4. தேர்ந்தெடுக்கப்பட்ட விதியைச் செயல்படுத்தவும் மற்றும் problem state இல் புதிய அறிவு துண்டைச் சேர்க்கவும்
5. படி 1 இல் இருந்து மீண்டும் தொடங்கவும்.

எனினும், சில சந்தர்ப்பங்களில், பிரச்சினை பற்றிய அறிவு இல்லாமல் தொடங்க விரும்புகிறோம், மேலும் முடிவுக்கு வர உதவக்கூடிய கேள்விகளை கேட்க விரும்புகிறோம். உதாரணமாக, மருத்துவ நோயறிதலில், நோயாளியை நோயறிதல் செய்யத் தொடங்குவதற்கு முன் அனைத்து மருத்துவ பரிசோதனைகளையும் முன்னதாகச் செய்ய மாட்டோம். ஒரு முடிவை எடுக்க வேண்டிய போது பரிசோதனைகளைச் செய்ய விரும்புகிறோம்.

இந்த செயல்முறையை **backward inference** ஐப் பயன்படுத்தி மாதிரியாக்கலாம். இது **goal** மூலம் இயக்கப்படுகிறது - நாம் கண்டுபிடிக்க முயற்சிக்கும் attribute value:

1. ஒரு goal இன் மதிப்பை நமக்கு வழங்கக்கூடிய அனைத்து விதிகளையும் தேர்ந்தெடுக்கவும் (அதாவது goal ஐ RHS ("right-hand-side") இல் கொண்டது) - conflict set
1. இந்த attribute க்கு விதிகள் இல்லை அல்லது பயனரிடமிருந்து மதிப்பை கேட்க வேண்டும் என்று கூறும் விதி இருந்தால் - கேட்கவும், இல்லையெனில்:
1. conflict resolution strategy ஐப் பயன்படுத்தி நாங்கள் *hypothesis* ஆகப் பயன்படுத்தும் ஒரு விதியைத் தேர்ந்தெடுக்கவும் - அதை நிரூபிக்க முயற்சிக்கவும்
1. goal களை நிரூபிக்க முயற்சித்து, விதியின் LHS இல் உள்ள அனைத்து attributes க்கும் செயல்முறையை மீண்டும் மீண்டும் செய்யவும்
1. எந்த நேரத்திலும் செயல்முறை தோல்வியடையுமானால் - படி 3 இல் மற்றொரு விதியைப் பயன்படுத்தவும்.

> ✅ எந்த சூழல்களில் forward inference அதிகம் பொருத்தமாக இருக்கும்? backward inference எப்படி?

### நிபுணர் அமைப்புகளை செயல்படுத்துதல்

நிபுணர் அமைப்புகள் பல கருவிகளைப் பயன்படுத்தி செயல்படுத்தப்படலாம்:

* சில உயர் நிலை நிரலாக்க மொழியில் நேரடியாக நிரலாக்கம். இது சிறந்த யோசனை அல்ல, ஏனெனில் ஒரு problem domain expert inference செயல்முறையின் விவரங்களைப் புரிந்துகொள்ளாமல் விதிகளை எழுத முடியும் என்பதே அறிவு அடிப்படையிலான அமைப்பின் முக்கிய நன்மையாகும்.
* **Expert systems shell** ஐப் பயன்படுத்துதல், அதாவது ஒரு knowledge representation language ஐப் பயன்படுத்தி அறிவு நிரப்புவதற்காக குறிப்பாக வடிவமைக்கப்பட்ட ஒரு அமைப்பு.

## ✍️ பயிற்சி: விலங்கு inference

[Animals.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/Animals.ipynb) ஐ forward மற்றும் backward inference expert system ஐ செயல்படுத்துவதற்கான உதாரணமாகப் பார்க்கவும்.

> **குறிப்பு**: இந்த உதாரணம் மிகவும் எளிமையானது, மேலும் ஒரு நிபுணர் அமைப்பு எப்படி இருக்கும் என்பதைப் பற்றிய கருத்தை மட்டுமே வழங்குகிறது. நீங்கள் ஒரு அமைப்பை உருவாக்கத் தொடங்கும் போது, ​​200+ விதிகள் வரை சென்ற பிறகே சில *புத்திசாலி* நடத்தை அதிலிருந்து நீங்கள் கவனிக்க ஆரம்பிப்பீர்கள். ஒரு கட்டத்தில், விதிகள் மிகவும் சிக்கலாகி, அவற்றை அனைத்தையும் மனதில் வைத்திருக்க முடியாது, மேலும் இந்த கட்டத்தில் ஒரு அமைப்பு ஏன் குறிப்பிட்ட முடிவுகளை எடுக்கிறது என்று நீங்கள் ஆச்சரியப்படலாம். எனினும், அறிவு அடிப்படையிலான அமைப்பின் முக்கியமான பண்புகள் என்னவென்றால், எந்த முடிவும் எவ்வாறு எடுக்கப்பட்டது என்பதை நீங்கள் எப்போதும் *விளக்க* முடியும்.

## Ontologies
- XML அடிப்படையிலான மொழிகளின் குடும்பம்: RDF (Resource Description Framework), RDFS (RDF Schema), OWL (Ontology Web Language).

Semantic Web இல் முக்கியமான கருத்து **Ontology** ஆகும். இது ஒரு பிரச்சினை துறையை தெளிவாகக் குறிப்பிடுவதற்கான ஒரு முறையான அறிவு பிரதிநிதித்துவத்தை குறிக்கிறது. மிக எளிய Ontology என்பது ஒரு பிரச்சினை துறையில் உள்ள பொருட்களின் ஒரு வரிசையாக இருக்கலாம், ஆனால் மேலும் சிக்கலான Ontology-கள் inference செய்ய பயன்படும் விதிகளை உள்ளடக்கும்.

Semantic Web இல், அனைத்து பிரதிநிதித்துவங்களும் triplets அடிப்படையில் அமைக்கப்பட்டுள்ளன. ஒவ்வொரு பொருளும் மற்றும் ஒவ்வொரு தொடர்பும் URI மூலம் தனித்துவமாக அடையாளம் காணப்படுகிறது. உதாரணமாக, இந்த AI Curriculum-ஐ Dmitry Soshnikov ஜனவரி 1, 2022 அன்று உருவாக்கியதாகக் கூற விரும்பினால், நாம் பயன்படுத்தக்கூடிய triplets இவை:

<img src="../../../../translated_images/triplet.4b9b332587593298b31846eb5cf341d8f7e48da76e6692dbb7cf0fcf2fd5ab38.ta.png" width="30%"/>

```
http://github.com/microsoft/ai-for-beginners http://www.example.com/terms/creation-date “Jan 13, 2007”
http://github.com/microsoft/ai-for-beginners http://purl.org/dc/elements/1.1/creator http://soshnikov.com
```

> ✅ இங்கு `http://www.example.com/terms/creation-date` மற்றும் `http://purl.org/dc/elements/1.1/creator` ஆகியவை *creator* மற்றும் *creation date* ஆகிய கருத்துகளை வெளிப்படுத்துவதற்கான சில பரவலாக ஏற்றுக்கொள்ளப்பட்ட URI-கள்.

சிக்கலான சூழலில், உருவாக்குநர்களின் பட்டியலை வரையறுக்க விரும்பினால், RDF-ல் வரையறுக்கப்பட்ட சில தரவமைப்புகளை பயன்படுத்தலாம்.

<img src="../../../../translated_images/triplet-complex.32094972c7b4441b844bd85e683ba8eedc08af12177160f11584452698f29ace.ta.png" width="40%"/>

> மேலே உள்ள வரைபடங்கள் [Dmitry Soshnikov](http://soshnikov.com) மூலம்.

Semantic Web உருவாக்கத்தின் முன்னேற்றம் தேடுபொறிகள் மற்றும் இயற்கை மொழி செயலாக்க நுட்பங்களின் வெற்றியால் தடைப்பட்டுவிட்டது, இது உரையிலிருந்து அமைந்த தரவுகளை எடுக்க அனுமதிக்கிறது. இருப்பினும், சில துறைகளில் Ontology-கள் மற்றும் அறிவு அடுக்குகளை பராமரிக்க குறிப்பிடத்தக்க முயற்சிகள் இன்னும் உள்ளன. குறிப்பிடத்தக்க சில திட்டங்கள்:

* [WikiData](https://wikidata.org/) என்பது Wikipedia-க்கு தொடர்புடைய இயந்திரம் வாசிக்கக்கூடிய அறிவு அடுக்குகளின் தொகுப்பாகும். பெரும்பாலான தரவுகள் Wikipedia *InfoBoxes*-இலிருந்து, Wikipedia பக்கங்களின் உள்ளடக்கத்தில் இருந்து எடுக்கப்படுகிறது. நீங்கள் [SPARQL](https://query.wikidata.org/) மூலம் WikiData-ஐ கேள்வி கேட்கலாம், இது Semantic Web-க்கு ஒரு சிறப்பு கேள்வி மொழியாகும். மனிதர்களிடையே மிகவும் பிரபலமான கண் நிறங்களை காட்டும் ஒரு மாதிரி கேள்வி இதோ:

```sparql
#defaultView:BubbleChart
SELECT ?eyeColorLabel (COUNT(?human) AS ?count)
WHERE
{
  ?human wdt:P31 wd:Q5.       # human instance-of homo sapiens
  ?human wdt:P1340 ?eyeColor. # human eye-color ?eyeColor
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
GROUP BY ?eyeColorLabel
```

* [DBpedia](https://www.dbpedia.org/) என்பது WikiData-க்கு ஒத்த ஒரு முயற்சி.

> ✅ உங்கள் சொந்த Ontology-களை உருவாக்க அல்லது ஏற்கனவே உள்ளவற்றைத் திறக்க முயற்சிக்க விரும்பினால், [Protégé](https://protege.stanford.edu/) என்ற ஒரு சிறந்த காட்சி Ontology தொகுப்பியைப் பயன்படுத்தலாம். இதைப் பதிவிறக்கவும் அல்லது ஆன்லைனில் பயன்படுத்தவும்.

<img src="../../../../translated_images/protege.274177ceeac13b38094bc425073776bb0d2525620ad6261b9d9760ebd2a8e322.ta.png" width="70%"/>

*Romanov குடும்ப Ontology-யுடன் திறந்த Web Protégé தொகுப்பி. Dmitry Soshnikov மூலம் எடுத்த படக்காட்சி*

## ✍️ பயிற்சி: குடும்ப Ontology

Semantic Web நுட்பங்களைப் பயன்படுத்தி குடும்ப உறவுகளைப் பற்றி ஆராய [FamilyOntology.ipynb](https://github.com/Ezana135/AI-For-Beginners/blob/main/lessons/2-Symbolic/FamilyOntology.ipynb) ஐப் பார்க்கவும். பொதுவான GEDCOM வடிவத்தில் பிரதிநிதித்துவப்படுத்தப்பட்ட குடும்ப மரம் மற்றும் குடும்ப உறவுகளின் Ontology-யை எடுத்து, கொடுக்கப்பட்ட நபர்களின் தொகுப்புக்கான அனைத்து குடும்ப உறவுகளின் ஒரு வரைபடத்தை உருவாக்குவோம்.

## Microsoft Concept Graph

பொதுவாக, Ontology-கள் கவனமாக கையால் உருவாக்கப்படுகின்றன. இருப்பினும், இயற்கை மொழி உரைகளிலிருந்து, உதாரணமாக, அமைப்பற்ற தரவிலிருந்து Ontology-களை **கோர** முடியும்.

Microsoft Research மூலம் மேற்கொள்ளப்பட்ட ஒரு முயற்சி [Microsoft Concept Graph](https://blogs.microsoft.com/ai/microsoft-researchers-release-graph-that-helps-machines-conceptualize/?WT.mc_id=academic-77998-cacaste) ஆகும்.

இது `is-a` மரபு உறவுகளைப் பயன்படுத்தி குழுவாக்கப்பட்ட பொருட்களின் ஒரு பெரிய தொகுப்பாகும். "Microsoft என்ன?" போன்ற கேள்விகளுக்கு பதிலளிக்க இது உதவுகிறது - பதில் "ஒரு நிறுவனம் (Probability 0.87) மற்றும் ஒரு பிராண்ட் (Probability 0.75)" போன்றதாக இருக்கும்.

இந்த Graph REST API ஆகவும், அல்லது அனைத்து entity ஜோடிகளையும் பட்டியலிடும் ஒரு பெரிய பதிவிறக்கக்கூடிய உரை கோப்பாகவும் கிடைக்கிறது.

## ✍️ பயிற்சி: ஒரு Concept Graph

செய்தி கட்டுரைகளை பல வகைகளில் குழுவாக்க Microsoft Concept Graph-ஐ எப்படி பயன்படுத்தலாம் என்பதைப் பார்க்க [MSConceptGraph.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/MSConceptGraph.ipynb) நோட்புக் முயற்சிக்கவும்.

## முடிவு

இன்றைய காலத்தில், AI பெரும்பாலும் *Machine Learning* அல்லது *Neural Networks* என்பதற்கான ஒத்த பொருளாகக் கருதப்படுகிறது. இருப்பினும், மனிதன் தெளிவான காரணங்களை வெளிப்படுத்துகிறான், இது தற்போதைய Neural Networks கையாள முடியாத ஒன்றாகும். உண்மையான உலக திட்டங்களில், விளக்கங்கள் தேவைப்படும் அல்லது அமைப்பின் நடத்தை கட்டுப்படுத்தப்பட்ட முறையில் மாற்றுவதற்கான பணிகளைச் செய்ய தெளிவான காரணங்கள் இன்னும் பயன்படுத்தப்படுகின்றன.

## 🚀 சவால்

இந்த பாடத்துடன் தொடர்புடைய குடும்ப Ontology நோட்புக்கில், குடும்ப மரத்தில் உள்ள மற்ற குடும்ப உறவுகளுடன் பரிசோதிக்க வாய்ப்பு உள்ளது. குடும்ப மரத்தில் உள்ள மக்களுக்கிடையே புதிய தொடர்புகளை கண்டறிய முயற்சிக்கவும்.

## [பாடத்திற்குப் பிந்தைய வினாடி வினா](https://ff-quizzes.netlify.app/en/ai/quiz/4)

## மதிப்பீடு மற்றும் சுயபயிற்சி

மனிதர்கள் அறிவை அளவிடவும் குறியிடவும் முயற்சித்துள்ள பகுதிகளை கண்டறிய இணையத்தில் சில ஆராய்ச்சிகளைச் செய்யவும். Bloom's Taxonomy-ஐப் பாருங்கள், மேலும் மனிதர்கள் தங்கள் உலகத்தைப் புரிந்துகொள்ள முயற்சித்த வரலாற்றைத் திரும்பிப் பாருங்கள். Linnaeus-ன் வேலைகளை ஆராய்ந்து, உயிரினங்களின் ஒரு Taxonomy உருவாக்கவும், மற்றும் Dmitri Mendeleev வேதியியல் கூறுகளை விவரிக்கவும் குழுவாக்கவும் ஒரு வழியை உருவாக்கிய விதத்தை கவனிக்கவும். நீங்கள் மேலும் எந்த 흥미로운 உதாரணங்களை கண்டறிய முடியும்?

**பணி**: [Ontology உருவாக்கவும்](assignment.md)

---

**குறிப்பு**:  
இந்த ஆவணம் AI மொழிபெயர்ப்பு சேவை [Co-op Translator](https://github.com/Azure/co-op-translator) பயன்படுத்தி மொழிபெயர்க்கப்பட்டுள்ளது. நாங்கள் துல்லியத்திற்காக முயற்சிக்கின்றோம், ஆனால் தானியங்கி மொழிபெயர்ப்புகளில் பிழைகள் அல்லது தவறான தகவல்கள் இருக்கக்கூடும் என்பதை கவனத்தில் கொள்ளவும். அதன் தாய்மொழியில் உள்ள மூல ஆவணம் அதிகாரப்பூர்வ ஆதாரமாக கருதப்பட வேண்டும். முக்கியமான தகவல்களுக்கு, தொழில்முறை மனித மொழிபெயர்ப்பு பரிந்துரைக்கப்படுகிறது. இந்த மொழிபெயர்ப்பைப் பயன்படுத்துவதால் ஏற்படும் எந்த தவறான புரிதல்கள் அல்லது தவறான விளக்கங்களுக்கு நாங்கள் பொறுப்பல்ல.