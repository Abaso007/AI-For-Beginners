<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "98c5222ff9556b55223fed2337145e18",
  "translation_date": "2025-08-24T10:04:05+00:00",
  "source_file": "lessons/2-Symbolic/README.md",
  "language_code": "hi"
}
-->
*छवि [विकिपीडिया से](https://commons.wikimedia.org/w/index.php?curid=37705247), By Longlivetheux - Own work, CC BY-SA 4.0*

इस प्रकार, **ज्ञान प्रतिनिधित्व** की समस्या यह है कि कंप्यूटर के अंदर डेटा के रूप में ज्ञान को प्रभावी ढंग से कैसे प्रस्तुत किया जाए, ताकि इसे स्वचालित रूप से उपयोग किया जा सके। इसे एक स्पेक्ट्रम के रूप में देखा जा सकता है:

![ज्ञान प्रतिनिधित्व स्पेक्ट्रम](../../../../lessons/2-Symbolic/images/knowledge-spectrum.png)

> छवि [दिमित्री सोश्निकोव](http://soshnikov.com) द्वारा

* बाईं ओर, बहुत सरल प्रकार के ज्ञान प्रतिनिधित्व हैं जो कंप्यूटर द्वारा प्रभावी रूप से उपयोग किए जा सकते हैं। सबसे सरल है एल्गोरिदमिक, जब ज्ञान को एक कंप्यूटर प्रोग्राम के रूप में प्रस्तुत किया जाता है। हालांकि, यह ज्ञान को प्रस्तुत करने का सबसे अच्छा तरीका नहीं है, क्योंकि यह लचीला नहीं है। हमारे दिमाग में मौजूद ज्ञान अक्सर गैर-एल्गोरिदमिक होता है।
* दाईं ओर, प्राकृतिक पाठ जैसे प्रतिनिधित्व हैं। यह सबसे शक्तिशाली है, लेकिन स्वचालित तर्क के लिए उपयोगी नहीं है।

> ✅ एक मिनट के लिए सोचें कि आप अपने दिमाग में ज्ञान को कैसे प्रस्तुत करते हैं और इसे नोट्स में बदलते हैं। क्या कोई विशेष प्रारूप है जो आपको इसे याद रखने में मदद करता है?

## कंप्यूटर ज्ञान प्रतिनिधित्व को वर्गीकृत करना

हम कंप्यूटर ज्ञान प्रतिनिधित्व के विभिन्न तरीकों को निम्नलिखित श्रेणियों में वर्गीकृत कर सकते हैं:

* **नेटवर्क प्रतिनिधित्व** इस तथ्य पर आधारित हैं कि हमारे दिमाग में आपस में जुड़े हुए अवधारणाओं का एक नेटवर्क होता है। हम उसी नेटवर्क को कंप्यूटर के अंदर एक ग्राफ के रूप में पुन: उत्पन्न करने की कोशिश कर सकते हैं - जिसे **सामांतिक नेटवर्क** कहा जाता है।

1. **ऑब्जेक्ट-एट्रिब्यूट-वैल्यू ट्रिपलेट्स** या **एट्रिब्यूट-वैल्यू पेयर्स**। चूंकि एक ग्राफ को कंप्यूटर के अंदर नोड्स और एजेस की सूची के रूप में प्रस्तुत किया जा सकता है, हम एक सामांतिक नेटवर्क को ट्रिपलेट्स की सूची के रूप में प्रस्तुत कर सकते हैं, जिसमें ऑब्जेक्ट्स, एट्रिब्यूट्स और वैल्यूज शामिल हैं। उदाहरण के लिए, हम प्रोग्रामिंग भाषाओं के बारे में निम्नलिखित ट्रिपलेट्स बना सकते हैं:

ऑब्जेक्ट | एट्रिब्यूट | वैल्यू
---------|------------|------
Python   | है         | Untyped-Language
Python   | आविष्कारक  | Guido van Rossum
Python   | ब्लॉक-सिंटैक्स | इंडेंटेशन
Untyped-Language | नहीं है | टाइप डिफिनिशन

> ✅ सोचें कि ट्रिपलेट्स का उपयोग अन्य प्रकार के ज्ञान को प्रस्तुत करने के लिए कैसे किया जा सकता है।

2. **पदानुक्रमिक प्रतिनिधित्व** इस तथ्य पर जोर देते हैं कि हम अक्सर अपने दिमाग में वस्तुओं का एक पदानुक्रम बनाते हैं। उदाहरण के लिए, हम जानते हैं कि कैनरी एक पक्षी है, और सभी पक्षियों के पंख होते हैं। हमें यह भी पता है कि कैनरी का रंग आमतौर पर क्या होता है, और उनकी उड़ान की गति क्या है।

   - **फ्रेम प्रतिनिधित्व** प्रत्येक वस्तु या वस्तुओं के वर्ग को **फ्रेम** के रूप में प्रस्तुत करने पर आधारित है, जिसमें **स्लॉट्स** होते हैं। स्लॉट्स में संभावित डिफ़ॉल्ट मान, मान प्रतिबंध, या संग्रहीत प्रक्रियाएं हो सकती हैं जिन्हें स्लॉट का मान प्राप्त करने के लिए बुलाया जा सकता है। सभी फ्रेम एक पदानुक्रम बनाते हैं, जो वस्तु-उन्मुख प्रोग्रामिंग भाषाओं में वस्तु पदानुक्रम के समान होता है।
   - **परिदृश्य** फ्रेम का एक विशेष प्रकार है जो जटिल स्थितियों का प्रतिनिधित्व करता है जो समय के साथ विकसित हो सकती हैं।

**Python**

स्लॉट | मान | डिफ़ॉल्ट मान | अंतराल |
------|-----|--------------|--------|
नाम   | Python | | |
है-एक | Untyped-Language | | |
वेरिएबल केस | | CamelCase | |
प्रोग्राम लंबाई | | | 5-5000 पंक्तियाँ |
ब्लॉक सिंटैक्स | इंडेंट | | |

3. **प्रक्रियात्मक प्रतिनिधित्व** ज्ञान को क्रियाओं की एक सूची के रूप में प्रस्तुत करने पर आधारित है, जिन्हें किसी विशेष स्थिति में निष्पादित किया जा सकता है।
   - उत्पादन नियम "यदि-तो" कथन होते हैं जो हमें निष्कर्ष निकालने की अनुमति देते हैं। उदाहरण के लिए, एक डॉक्टर के पास एक नियम हो सकता है जो कहता है कि **यदि** किसी मरीज को तेज बुखार है **या** रक्त परीक्षण में सी-रिएक्टिव प्रोटीन का उच्च स्तर है **तो** उसे सूजन है। एक बार जब हम इनमें से किसी एक स्थिति का सामना करते हैं, तो हम सूजन के बारे में निष्कर्ष निकाल सकते हैं, और फिर इसे आगे के तर्क में उपयोग कर सकते हैं।
   - एल्गोरिदम को प्रक्रियात्मक प्रतिनिधित्व का एक और रूप माना जा सकता है, हालांकि उन्हें ज्ञान-आधारित प्रणालियों में सीधे उपयोग नहीं किया जाता है।

4. **तर्क** मूल रूप से अरस्तू द्वारा सार्वभौमिक मानव ज्ञान का प्रतिनिधित्व करने के एक तरीके के रूप में प्रस्तावित किया गया था।
   - प्रेडिकेट लॉजिक एक गणितीय सिद्धांत के रूप में बहुत समृद्ध है, इसलिए इसका कुछ उपसमुच्चय आमतौर पर उपयोग किया जाता है, जैसे कि प्रोलॉग में उपयोग किए जाने वाले हॉर्न क्लॉज।
   - वर्णनात्मक तर्क तर्क प्रणालियों का एक परिवार है जो वस्तुओं के पदानुक्रम और वितरित ज्ञान प्रतिनिधित्व जैसे *सामांतिक वेब* के बारे में तर्क करने के लिए उपयोग किया जाता है।

## विशेषज्ञ प्रणालियाँ

प्रतीकात्मक एआई की शुरुआती सफलताओं में से एक **विशेषज्ञ प्रणालियाँ** थीं - कंप्यूटर सिस्टम जिन्हें किसी सीमित समस्या डोमेन में विशेषज्ञ के रूप में कार्य करने के लिए डिज़ाइन किया गया था। ये **ज्ञान आधार** पर आधारित थीं, जो एक या अधिक मानव विशेषज्ञों से निकाली गई थीं, और इनमें एक **तर्क इंजन** था जो इसके ऊपर कुछ तर्क करता था।

![मानव संरचना](../../../../lessons/2-Symbolic/images/arch-human.png) | ![ज्ञान-आधारित प्रणाली](../../../../lessons/2-Symbolic/images/arch-kbs.png)
---------------------------------------|--------------------------------------------
मानव तंत्रिका तंत्र की सरलीकृत संरचना | ज्ञान-आधारित प्रणाली की संरचना

विशेषज्ञ प्रणालियाँ मानव तर्क प्रणाली की तरह बनाई जाती हैं, जिसमें **अल्पकालिक स्मृति** और **दीर्घकालिक स्मृति** होती है। इसी तरह, ज्ञान-आधारित प्रणालियों में हम निम्नलिखित घटकों को अलग करते हैं:

* **समस्या स्मृति**: इसमें वर्तमान में हल की जा रही समस्या के बारे में ज्ञान होता है, जैसे कि किसी मरीज का तापमान या रक्तचाप, क्या उसे सूजन है या नहीं, आदि। इस ज्ञान को **स्थिर ज्ञान** भी कहा जाता है, क्योंकि इसमें समस्या के बारे में वर्तमान में ज्ञात जानकारी का स्नैपशॉट होता है - जिसे *समस्या स्थिति* कहा जाता है।
* **ज्ञान आधार**: यह समस्या डोमेन के बारे में दीर्घकालिक ज्ञान का प्रतिनिधित्व करता है। इसे मानव विशेषज्ञों से मैन्युअल रूप से निकाला जाता है, और परामर्श से परामर्श तक नहीं बदलता। क्योंकि यह हमें एक समस्या स्थिति से दूसरी में नेविगेट करने की अनुमति देता है, इसे **गतिशील ज्ञान** भी कहा जाता है।
* **तर्क इंजन**: यह समस्या स्थिति स्थान में खोज प्रक्रिया को व्यवस्थित करता है, और जब आवश्यक हो तो उपयोगकर्ता से प्रश्न पूछता है। यह प्रत्येक स्थिति पर लागू होने वाले सही नियमों को खोजने के लिए भी जिम्मेदार होता है।

उदाहरण के लिए, चलिए एक जानवर की भौतिक विशेषताओं के आधार पर उसे पहचानने की विशेषज्ञ प्रणाली पर विचार करते हैं:

![AND-OR ट्री](../../../../lessons/2-Symbolic/images/AND-OR-Tree.png)

> छवि [दिमित्री सोश्निकोव](http://soshnikov.com) द्वारा

इस आरेख को **AND-OR ट्री** कहा जाता है, और यह उत्पादन नियमों के सेट का एक ग्राफिकल प्रतिनिधित्व है। विशेषज्ञ से ज्ञान निकालने की शुरुआत में एक ट्री बनाना उपयोगी होता है। कंप्यूटर के अंदर ज्ञान का प्रतिनिधित्व करने के लिए नियमों का उपयोग करना अधिक सुविधाजनक होता है:

```
IF the animal eats meat
OR (animal has sharp teeth
    AND animal has claws
    AND animal has forward-looking eyes
) 
THEN the animal is a carnivore
```

आप देख सकते हैं कि नियम के बाएँ हाथ की स्थिति और क्रिया वस्तु-एट्रिब्यूट-वैल्यू (OAV) ट्रिपलेट्स के समान हैं। **कार्यशील स्मृति** OAV ट्रिपलेट्स का सेट रखती है जो वर्तमान में हल की जा रही समस्या से मेल खाती है। एक **नियम इंजन** उन नियमों की खोज करता है जिनकी स्थिति संतुष्ट होती है और उन्हें लागू करता है, कार्यशील स्मृति में एक और ट्रिपलेट जोड़ता है।

> ✅ अपने पसंदीदा विषय पर अपना खुद का AND-OR ट्री बनाएं!

### फॉरवर्ड बनाम बैकवर्ड तर्क

ऊपर वर्णित प्रक्रिया को **फॉरवर्ड तर्क** कहा जाता है। यह कार्यशील स्मृति में समस्या के बारे में प्रारंभिक डेटा के साथ शुरू होता है, और फिर निम्नलिखित तर्क चक्र को निष्पादित करता है:

1. यदि लक्ष्य विशेषता कार्यशील स्मृति में मौजूद है - रुकें और परिणाम दें।
2. उन सभी नियमों की खोज करें जिनकी स्थिति वर्तमान में संतुष्ट है - **संघर्ष सेट** प्राप्त करें।
3. **संघर्ष समाधान** करें - उस नियम का चयन करें जिसे इस चरण में निष्पादित किया जाएगा। विभिन्न संघर्ष समाधान रणनीतियाँ हो सकती हैं:
   - ज्ञान आधार में पहला लागू नियम चुनें।
   - एक यादृच्छिक नियम चुनें।
   - एक *अधिक विशिष्ट* नियम चुनें, यानी वह जो "बाएँ हाथ की स्थिति" (LHS) में सबसे अधिक स्थितियों को पूरा करता हो।
4. चयनित नियम लागू करें और समस्या स्थिति में नया ज्ञान जोड़ें।
5. चरण 1 से दोहराएँ।

हालांकि, कुछ मामलों में हम समस्या के बारे में खाली ज्ञान के साथ शुरू करना चाहते हैं, और ऐसे प्रश्न पूछना चाहते हैं जो हमें निष्कर्ष तक पहुँचने में मदद करें। उदाहरण के लिए, जब चिकित्सा निदान किया जा रहा हो, तो हम आमतौर पर सभी चिकित्सा परीक्षण पहले से नहीं करते। हम निर्णय लेने के लिए आवश्यक होने पर परीक्षण करना चाहते हैं।

इस प्रक्रिया को **बैकवर्ड तर्क** का उपयोग करके मॉडल किया जा सकता है। यह **लक्ष्य** द्वारा संचालित होता है - वह विशेषता मान जिसे हम खोजना चाहते हैं:

1. उन सभी नियमों का चयन करें जो हमें लक्ष्य का मान दे सकते हैं (यानी लक्ष्य RHS ("राइट-हैंड-साइड") पर हो) - एक संघर्ष सेट।
1. यदि इस विशेषता के लिए कोई नियम नहीं है, या कोई नियम कहता है कि हमें उपयोगकर्ता से मान पूछना चाहिए - पूछें, अन्यथा:
1. संघर्ष समाधान रणनीति का उपयोग करके एक नियम का चयन करें जिसे हम *परिकल्पना* के रूप में उपयोग करेंगे - हम इसे साबित करने की कोशिश करेंगे।
1. नियम के LHS में सभी विशेषताओं के लिए प्रक्रिया को पुनरावर्ती रूप से दोहराएँ, उन्हें लक्ष्यों के रूप में साबित करने की कोशिश करें।
1. यदि किसी भी बिंदु पर प्रक्रिया विफल हो जाती है - चरण 3 पर दूसरा नियम उपयोग करें।

> ✅ किन स्थितियों में फॉरवर्ड तर्क अधिक उपयुक्त है? और बैकवर्ड तर्क कब उपयोगी है?

### विशेषज्ञ प्रणालियों को लागू करना

विशेषज्ञ प्रणालियों को विभिन्न उपकरणों का उपयोग करके लागू किया जा सकता है:

* किसी उच्च स्तरीय प्रोग्रामिंग भाषा में सीधे प्रोग्रामिंग करना। यह सबसे अच्छा विचार नहीं है, क्योंकि ज्ञान-आधारित प्रणाली का मुख्य लाभ यह है कि ज्ञान को तर्क से अलग किया जाता है, और संभावित रूप से एक समस्या डोमेन विशेषज्ञ को नियम लिखने में सक्षम होना चाहिए बिना तर्क प्रक्रिया के विवरण को समझे।
* **विशेषज्ञ प्रणाली शेल** का उपयोग करना, यानी एक प्रणाली जिसे विशेष रूप से किसी ज्ञान प्रतिनिधित्व भाषा का उपयोग करके ज्ञान से भरा जा सके।

## ✍️ अभ्यास: जानवर तर्क

फॉरवर्ड और बैकवर्ड तर्क विशेषज्ञ प्रणाली को लागू करने के उदाहरण के लिए [Animals.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/Animals.ipynb) देखें।
> **नोट**: यह उदाहरण काफी सरल है और केवल यह दिखाने के लिए है कि एक विशेषज्ञ प्रणाली कैसी दिखती है। जब आप ऐसी प्रणाली बनाना शुरू करेंगे, तो आपको इसमें कुछ *बुद्धिमान* व्यवहार तभी दिखाई देगा जब आप लगभग 200+ नियमों तक पहुँचेंगे। एक समय के बाद, नियम इतने जटिल हो जाते हैं कि सभी को याद रखना मुश्किल हो जाता है, और इस बिंदु पर आप सोच सकते हैं कि प्रणाली ने कुछ विशेष निर्णय क्यों लिए। हालांकि, ज्ञान-आधारित प्रणालियों की एक महत्वपूर्ण विशेषता यह है कि आप हमेशा *समझा सकते हैं* कि किसी भी निर्णय को कैसे लिया गया।
## ऑंटोलॉजी और सेमांटिक वेब

20वीं सदी के अंत में एक पहल की गई थी कि इंटरनेट संसाधनों को ज्ञान प्रतिनिधित्व के माध्यम से एनोटेट किया जाए, ताकि बहुत विशिष्ट प्रश्नों के लिए उपयुक्त संसाधन ढूंढे जा सकें। इस पहल को **सेमांटिक वेब** कहा गया, और यह कई अवधारणाओं पर आधारित था:

- **[डिस्क्रिप्शन लॉजिक](https://en.wikipedia.org/wiki/Description_logic)** (DL) पर आधारित एक विशेष ज्ञान प्रतिनिधित्व। यह फ्रेम ज्ञान प्रतिनिधित्व के समान है, क्योंकि यह गुणों के साथ वस्तुओं की एक पदानुक्रम बनाता है, लेकिन इसमें औपचारिक तार्किक अर्थ और निष्कर्षण होता है। DL का एक पूरा परिवार है, जो अभिव्यक्तता और निष्कर्षण की एल्गोरिदमिक जटिलता के बीच संतुलन बनाता है।
- वितरित ज्ञान प्रतिनिधित्व, जहां सभी अवधारणाओं को एक वैश्विक URI पहचानकर्ता द्वारा दर्शाया जाता है, जिससे इंटरनेट पर ज्ञान पदानुक्रम बनाना संभव हो जाता है।
- ज्ञान विवरण के लिए XML-आधारित भाषाओं का एक परिवार: RDF (रिसोर्स डिस्क्रिप्शन फ्रेमवर्क), RDFS (RDF स्कीमा), OWL (ऑंटोलॉजी वेब लैंग्वेज)।

सेमांटिक वेब में एक मुख्य अवधारणा **ऑंटोलॉजी** की है। यह किसी समस्या क्षेत्र का औपचारिक ज्ञान प्रतिनिधित्व का स्पष्ट विनिर्देशन है। सबसे सरल ऑंटोलॉजी केवल समस्या क्षेत्र में वस्तुओं की एक पदानुक्रम हो सकती है, लेकिन अधिक जटिल ऑंटोलॉजी में ऐसे नियम शामिल होंगे जो निष्कर्षण के लिए उपयोग किए जा सकते हैं।

सेमांटिक वेब में, सभी प्रतिनिधित्व ट्रिपलेट्स पर आधारित होते हैं। प्रत्येक वस्तु और प्रत्येक संबंध को URI द्वारा अद्वितीय रूप से पहचाना जाता है। उदाहरण के लिए, यदि हम यह तथ्य बताना चाहते हैं कि यह AI पाठ्यक्रम Dmitry Soshnikov द्वारा 1 जनवरी, 2022 को विकसित किया गया था - तो यहां वे ट्रिपलेट्स हैं जिन्हें हम उपयोग कर सकते हैं:

<img src="images/triplet.png" width="30%"/>

```
http://github.com/microsoft/ai-for-beginners http://www.example.com/terms/creation-date “Jan 13, 2007”
http://github.com/microsoft/ai-for-beginners http://purl.org/dc/elements/1.1/creator http://soshnikov.com
```

> ✅ यहां `http://www.example.com/terms/creation-date` और `http://purl.org/dc/elements/1.1/creator` कुछ प्रसिद्ध और सार्वभौमिक रूप से स्वीकृत URI हैं, जो *creator* और *creation date* की अवधारणाओं को व्यक्त करते हैं।

एक अधिक जटिल मामले में, यदि हम रचनाकारों की एक सूची परिभाषित करना चाहते हैं, तो हम RDF में परिभाषित कुछ डेटा संरचनाओं का उपयोग कर सकते हैं।

<img src="images/triplet-complex.png" width="40%"/>

> ऊपर के आरेख [Dmitry Soshnikov](http://soshnikov.com) द्वारा

सेमांटिक वेब के निर्माण की प्रगति को सर्च इंजन और प्राकृतिक भाषा प्रसंस्करण तकनीकों की सफलता ने धीमा कर दिया, जो पाठ से संरचित डेटा निकालने की अनुमति देती हैं। हालांकि, कुछ क्षेत्रों में ऑंटोलॉजी और ज्ञान आधार बनाए रखने के लिए अभी भी महत्वपूर्ण प्रयास किए जा रहे हैं। कुछ उल्लेखनीय परियोजनाएं:

* [WikiData](https://wikidata.org/) एक मशीन-पठनीय ज्ञान आधारों का संग्रह है जो Wikipedia से जुड़ा है। अधिकांश डेटा Wikipedia *InfoBoxes* से निकाला गया है, जो Wikipedia पृष्ठों के अंदर संरचित सामग्री के टुकड़े हैं। आप [SPARQL](https://query.wikidata.org/) में विकिडेटा को क्वेरी कर सकते हैं, जो सेमांटिक वेब के लिए एक विशेष क्वेरी भाषा है। यहां एक नमूना क्वेरी है जो मनुष्यों में सबसे लोकप्रिय आंखों के रंग दिखाती है:

```sparql
#defaultView:BubbleChart
SELECT ?eyeColorLabel (COUNT(?human) AS ?count)
WHERE
{
  ?human wdt:P31 wd:Q5.       # human instance-of homo sapiens
  ?human wdt:P1340 ?eyeColor. # human eye-color ?eyeColor
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
GROUP BY ?eyeColorLabel
```

* [DBpedia](https://www.dbpedia.org/) WikiData के समान एक और प्रयास है।

> ✅ यदि आप अपनी खुद की ऑंटोलॉजी बनाने या मौजूदा ऑंटोलॉजी खोलने के साथ प्रयोग करना चाहते हैं, तो [Protégé](https://protege.stanford.edu/) नामक एक शानदार विज़ुअल ऑंटोलॉजी एडिटर है। इसे डाउनलोड करें, या इसे ऑनलाइन उपयोग करें।

<img src="images/protege.png" width="70%"/>

*Web Protégé एडिटर Romanov Family ऑंटोलॉजी के साथ खुला। स्क्रीनशॉट Dmitry Soshnikov द्वारा*

## ✍️ अभ्यास: एक परिवार ऑंटोलॉजी

[FamilyOntology.ipynb](https://github.com/Ezana135/AI-For-Beginners/blob/main/lessons/2-Symbolic/FamilyOntology.ipynb) देखें, जो पारिवारिक संबंधों के बारे में तर्क करने के लिए सेमांटिक वेब तकनीकों का उपयोग करने का एक उदाहरण है। हम GEDCOM प्रारूप में एक पारिवारिक पेड़ और पारिवारिक संबंधों की एक ऑंटोलॉजी लेंगे और दिए गए व्यक्तियों के सेट के लिए सभी पारिवारिक संबंधों का एक ग्राफ बनाएंगे।

## माइक्रोसॉफ्ट कॉन्सेप्ट ग्राफ

अधिकांश मामलों में, ऑंटोलॉजी को सावधानीपूर्वक हाथ से बनाया जाता है। हालांकि, यह भी संभव है कि **असंरचित डेटा** से ऑंटोलॉजी निकाली जाएं, उदाहरण के लिए, प्राकृतिक भाषा के पाठ से।

Microsoft Research द्वारा ऐसा ही एक प्रयास किया गया था, जिसके परिणामस्वरूप [Microsoft Concept Graph](https://blogs.microsoft.com/ai/microsoft-researchers-release-graph-that-helps-machines-conceptualize/?WT.mc_id=academic-77998-cacaste) बना।

यह `is-a` उत्तराधिकार संबंध का उपयोग करके समूहित संस्थाओं का एक बड़ा संग्रह है। यह "Microsoft क्या है?" जैसे प्रश्नों का उत्तर देने की अनुमति देता है - उत्तर कुछ इस प्रकार हो सकता है "0.87 की संभावना के साथ एक कंपनी, और 0.75 की संभावना के साथ एक ब्रांड।"

ग्राफ़ REST API के रूप में या एक बड़े डाउनलोड करने योग्य टेक्स्ट फ़ाइल के रूप में उपलब्ध है, जिसमें सभी इकाई जोड़े सूचीबद्ध हैं।

## ✍️ अभ्यास: एक कॉन्सेप्ट ग्राफ

[MSConceptGraph.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/MSConceptGraph.ipynb) नोटबुक आज़माएं, यह देखने के लिए कि हम Microsoft Concept Graph का उपयोग करके समाचार लेखों को कई श्रेणियों में कैसे समूहित कर सकते हैं।

## निष्कर्ष

आजकल, AI को अक्सर *मशीन लर्निंग* या *न्यूरल नेटवर्क्स* का पर्याय माना जाता है। हालांकि, एक इंसान स्पष्ट तर्क भी प्रदर्शित करता है, जो कुछ ऐसा है जिसे वर्तमान में न्यूरल नेटवर्क संभाल नहीं रहे हैं। वास्तविक दुनिया की परियोजनाओं में, स्पष्ट तर्क का अभी भी उपयोग किया जाता है ताकि ऐसे कार्य किए जा सकें जिनमें स्पष्टीकरण की आवश्यकता हो, या सिस्टम के व्यवहार को नियंत्रित तरीके से संशोधित करने की आवश्यकता हो।

## 🚀 चुनौती

इस पाठ से संबंधित Family Ontology नोटबुक में, अन्य पारिवारिक संबंधों के साथ प्रयोग करने का अवसर है। परिवार के पेड़ में लोगों के बीच नए कनेक्शन खोजने का प्रयास करें।

## [पोस्ट-लेक्चर क्विज़](https://ff-quizzes.netlify.app/en/ai/quiz/4)

## समीक्षा और स्व-अध्ययन

इंटरनेट पर शोध करें और उन क्षेत्रों की खोज करें जहां मनुष्यों ने ज्ञान को मापने और कोडिफाई करने की कोशिश की है। Bloom's Taxonomy पर एक नज़र डालें, और इतिहास में वापस जाएं यह जानने के लिए कि मनुष्यों ने अपनी दुनिया को समझने की कोशिश कैसे की। Linnaeus के कार्य का अन्वेषण करें, जिन्होंने जीवों की एक वर्गीकरण प्रणाली बनाई, और यह देखें कि Dmitri Mendeleev ने रासायनिक तत्वों का वर्णन और समूह बनाने का तरीका कैसे बनाया। आप और कौन से दिलचस्प उदाहरण खोज सकते हैं?

**असाइनमेंट**: [ऑंटोलॉजी बनाएं](assignment.md)

**अस्वीकरण**:  
यह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को आधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।