<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "7d097f7fda9166ead615e4c34552381b",
  "translation_date": "2025-09-23T13:31:34+00:00",
  "source_file": "lessons/2-Symbolic/README.md",
  "language_code": "hi"
}
-->
# ज्ञान प्रतिनिधित्व और विशेषज्ञ प्रणाली

![सिंबोलिक AI सामग्री का सारांश](../../../../translated_images/ai-symbolic.715a30cb610411a6964d2e2f23f24364cb338a07cb4844c1f97084d366e586c3.hi.png)

> स्केच नोट [Tomomi Imura](https://twitter.com/girlie_mac) द्वारा

कृत्रिम बुद्धिमत्ता की खोज ज्ञान की खोज पर आधारित है, ताकि दुनिया को उसी तरह समझा जा सके जैसे मनुष्य करते हैं। लेकिन इसे कैसे किया जा सकता है?

## [प्री-लेक्चर क्विज़](https://ff-quizzes.netlify.app/en/ai/quiz/3)

AI के शुरुआती दिनों में, बुद्धिमान प्रणालियाँ बनाने के लिए टॉप-डाउन दृष्टिकोण (पिछले पाठ में चर्चा की गई) लोकप्रिय था। विचार यह था कि लोगों से ज्ञान निकालकर उसे मशीन-पढ़ने योग्य रूप में बदल दिया जाए, और फिर इसका उपयोग स्वचालित रूप से समस्याओं को हल करने के लिए किया जाए। यह दृष्टिकोण दो बड़े विचारों पर आधारित था:

* ज्ञान प्रतिनिधित्व
* तर्क

## ज्ञान प्रतिनिधित्व

सिंबोलिक AI में एक महत्वपूर्ण अवधारणा **ज्ञान** है। यह *सूचना* या *डेटा* से ज्ञान को अलग करना महत्वपूर्ण है। उदाहरण के लिए, कोई कह सकता है कि किताबें ज्ञान रखती हैं, क्योंकि कोई किताबें पढ़कर विशेषज्ञ बन सकता है। हालांकि, किताबों में जो होता है उसे वास्तव में *डेटा* कहा जाता है, और किताबें पढ़कर और इस डेटा को हमारे विश्व मॉडल में एकीकृत करके हम इसे ज्ञान में बदलते हैं।

> ✅ **ज्ञान** वह है जो हमारे दिमाग में होता है और दुनिया के प्रति हमारी समझ को दर्शाता है। यह एक सक्रिय **सीखने** की प्रक्रिया के माध्यम से प्राप्त होता है, जो हमें प्राप्त होने वाली सूचनाओं को हमारे सक्रिय विश्व मॉडल में एकीकृत करता है।

अक्सर, हम ज्ञान को सख्ती से परिभाषित नहीं करते हैं, बल्कि इसे [DIKW पिरामिड](https://en.wikipedia.org/wiki/DIKW_pyramid) के साथ अन्य संबंधित अवधारणाओं के साथ संरेखित करते हैं। इसमें निम्नलिखित अवधारणाएँ शामिल हैं:

* **डेटा** वह है जो भौतिक माध्यम में प्रस्तुत किया जाता है, जैसे लिखित पाठ या बोले गए शब्द। डेटा मनुष्यों से स्वतंत्र रूप से मौजूद होता है और इसे लोगों के बीच साझा किया जा सकता है।
* **सूचना** वह है जो हम अपने दिमाग में डेटा की व्याख्या करते हैं। उदाहरण के लिए, जब हम शब्द *कंप्यूटर* सुनते हैं, तो हमें इसके बारे में कुछ समझ होती है।
* **ज्ञान** वह है जब सूचना हमारे विश्व मॉडल में एकीकृत हो जाती है। उदाहरण के लिए, एक बार जब हम सीखते हैं कि कंप्यूटर क्या है, तो हमें इसके काम करने, इसकी लागत और इसके उपयोग के बारे में कुछ विचार होने लगते हैं। इन आपस में जुड़े अवधारणाओं का नेटवर्क हमारा ज्ञान बनाता है।
* **बुद्धिमत्ता** हमारी दुनिया की समझ का एक और स्तर है, और यह *मेटा-ज्ञान* का प्रतिनिधित्व करता है, जैसे कि यह ज्ञान कब और कैसे उपयोग किया जाना चाहिए।

<img src="images/DIKW_Pyramid.png" width="30%"/>

*छवि [विकिपीडिया से](https://commons.wikimedia.org/w/index.php?curid=37705247), Longlivetheux द्वारा - स्वयं का कार्य, CC BY-SA 4.0*

इस प्रकार, **ज्ञान प्रतिनिधित्व** की समस्या यह है कि कंप्यूटर के अंदर डेटा के रूप में ज्ञान को प्रभावी ढंग से कैसे प्रस्तुत किया जाए, ताकि इसे स्वचालित रूप से उपयोग किया जा सके। इसे एक स्पेक्ट्रम के रूप में देखा जा सकता है:

![ज्ञान प्रतिनिधित्व स्पेक्ट्रम](../../../../translated_images/knowledge-spectrum.b60df631852c0217e941485b79c9eee40ebd574f15f18609cec5758fcb384bf3.hi.png)

> छवि [Dmitry Soshnikov](http://soshnikov.com) द्वारा

* बाईं ओर, बहुत सरल प्रकार के ज्ञान प्रतिनिधित्व हैं जिन्हें कंप्यूटर द्वारा प्रभावी ढंग से उपयोग किया जा सकता है। सबसे सरल प्रकार एल्गोरिदमिक है, जब ज्ञान को कंप्यूटर प्रोग्राम के रूप में प्रस्तुत किया जाता है। हालांकि, यह ज्ञान को प्रस्तुत करने का सबसे अच्छा तरीका नहीं है, क्योंकि यह लचीला नहीं है। हमारे दिमाग में ज्ञान अक्सर गैर-एल्गोरिदमिक होता है।
* दाईं ओर, प्राकृतिक पाठ जैसे प्रतिनिधित्व हैं। यह सबसे शक्तिशाली है, लेकिन इसे स्वचालित तर्क के लिए उपयोग नहीं किया जा सकता।

> ✅ एक मिनट के लिए सोचें कि आप अपने दिमाग में ज्ञान को कैसे प्रस्तुत करते हैं और इसे नोट्स में बदलते हैं। क्या कोई विशेष प्रारूप है जो आपको इसे याद रखने में मदद करता है?

## कंप्यूटर ज्ञान प्रतिनिधित्व को वर्गीकृत करना

हम विभिन्न कंप्यूटर ज्ञान प्रतिनिधित्व विधियों को निम्नलिखित श्रेणियों में वर्गीकृत कर सकते हैं:

* **नेटवर्क प्रतिनिधित्व** इस तथ्य पर आधारित हैं कि हमारे दिमाग में आपस में जुड़े अवधारणाओं का एक नेटवर्क होता है। हम उसी नेटवर्क को कंप्यूटर के अंदर एक ग्राफ के रूप में पुन: उत्पन्न करने की कोशिश कर सकते हैं - जिसे **सामांतिक नेटवर्क** कहा जाता है।

1. **ऑब्जेक्ट-एट्रिब्यूट-वैल्यू ट्रिपलेट्स** या **एट्रिब्यूट-वैल्यू पेयर्स**। चूंकि एक ग्राफ को कंप्यूटर के अंदर नोड्स और एजेस की सूची के रूप में प्रस्तुत किया जा सकता है, हम एक सामांतिक नेटवर्क को ट्रिपलेट्स की सूची के रूप में प्रस्तुत कर सकते हैं, जिसमें ऑब्जेक्ट्स, एट्रिब्यूट्स और वैल्यूज शामिल हैं। उदाहरण के लिए, हम प्रोग्रामिंग भाषाओं के बारे में निम्नलिखित ट्रिपलेट्स बनाते हैं:

ऑब्जेक्ट | एट्रिब्यूट | वैल्यू
---------|------------|------
Python | है | Untyped-Language
Python | आविष्कारक | Guido van Rossum
Python | ब्लॉक-सिंटैक्स | इंडेंटेशन
Untyped-Language | नहीं है | टाइप डिफिनिशन

> ✅ सोचें कि ट्रिपलेट्स का उपयोग अन्य प्रकार के ज्ञान को प्रस्तुत करने के लिए कैसे किया जा सकता है।

2. **हाइरार्किकल प्रतिनिधित्व** इस तथ्य पर जोर देते हैं कि हम अक्सर अपने दिमाग में वस्तुओं का एक पदानुक्रम बनाते हैं। उदाहरण के लिए, हम जानते हैं कि कैनरी एक पक्षी है, और सभी पक्षियों के पंख होते हैं। हमें यह भी पता है कि कैनरी का रंग आमतौर पर क्या होता है, और उनकी उड़ान की गति क्या होती है।

   - **फ्रेम प्रतिनिधित्व** प्रत्येक वस्तु या वस्तुओं के वर्ग को **फ्रेम** के रूप में प्रस्तुत करने पर आधारित है जिसमें **स्लॉट्स** होते हैं। स्लॉट्स में संभावित डिफ़ॉल्ट मान, मान प्रतिबंध, या संग्रहीत प्रक्रियाएँ हो सकती हैं जिन्हें स्लॉट का मान प्राप्त करने के लिए बुलाया जा सकता है। सभी फ्रेम एक पदानुक्रम बनाते हैं जो वस्तु-उन्मुख प्रोग्रामिंग भाषाओं में वस्तु पदानुक्रम के समान है।
   - **परिदृश्य** फ्रेम का एक विशेष प्रकार हैं जो समय के साथ विकसित होने वाली जटिल स्थितियों का प्रतिनिधित्व करते हैं।

**Python**

स्लॉट | मान | डिफ़ॉल्ट मान | अंतराल |
------|------|--------------|--------|
नाम | Python | | |
है | Untyped-Language | | |
वेरिएबल केस | | CamelCase | |
प्रोग्राम लंबाई | | | 5-5000 लाइनें |
ब्लॉक सिंटैक्स | इंडेंट | | |

3. **प्रक्रियात्मक प्रतिनिधित्व** ज्ञान को क्रियाओं की सूची के रूप में प्रस्तुत करने पर आधारित हैं जिन्हें किसी निश्चित स्थिति में निष्पादित किया जा सकता है।
   - उत्पादन नियम if-then कथन हैं जो हमें निष्कर्ष निकालने की अनुमति देते हैं। उदाहरण के लिए, एक डॉक्टर के पास एक नियम हो सकता है जो कहता है कि **यदि** किसी मरीज को तेज बुखार है **या** रक्त परीक्षण में C-रिएक्टिव प्रोटीन का उच्च स्तर है **तो** उसे सूजन है। एक बार जब हम इनमें से किसी एक स्थिति का सामना करते हैं, तो हम सूजन के बारे में निष्कर्ष निकाल सकते हैं, और फिर इसे आगे के तर्क में उपयोग कर सकते हैं।
   - एल्गोरिदम को प्रक्रियात्मक प्रतिनिधित्व का एक और रूप माना जा सकता है, हालांकि वे लगभग कभी भी ज्ञान-आधारित प्रणालियों में सीधे उपयोग नहीं किए जाते।

4. **तर्क** मूल रूप से अरस्तू द्वारा सार्वभौमिक मानव ज्ञान को प्रस्तुत करने के तरीके के रूप में प्रस्तावित किया गया था।
   - प्रेडिकेट लॉजिक एक गणितीय सिद्धांत के रूप में बहुत समृद्ध है और इसलिए इसे गणना योग्य नहीं माना जाता है। इसलिए इसका कुछ उपसमुच्चय सामान्यतः उपयोग किया जाता है, जैसे कि Prolog में उपयोग किए जाने वाले Horn क्लॉज।
   - वर्णनात्मक तर्क वस्तुओं के पदानुक्रम और वितरित ज्ञान प्रतिनिधित्व जैसे *सामांतिक वेब* के बारे में तर्क करने के लिए उपयोग किए जाने वाले तर्क प्रणालियों का एक परिवार है।

## विशेषज्ञ प्रणाली

सिंबोलिक AI की शुरुआती सफलताओं में से एक **विशेषज्ञ प्रणाली** थीं - कंप्यूटर प्रणाली जो किसी सीमित समस्या क्षेत्र में विशेषज्ञ के रूप में कार्य करने के लिए डिज़ाइन की गई थीं। ये **ज्ञान आधार** पर आधारित थीं जो एक या अधिक मानव विशेषज्ञों से निकाली गई थीं, और इनमें एक **तर्क इंजन** था जो इसके ऊपर कुछ तर्क करता था।

![मानव संरचना](../../../../translated_images/arch-human.5d4d35f1bba3ab1cdfda96af2f10b89574eb31e9796d0e3011cd9beda1c35112.hi.png) | ![ज्ञान-आधारित प्रणाली](../../../../translated_images/arch-kbs.3ec5c150b09fa8dadc2beb0931a4983c9e2b03913a89eebcc103b5bb841b0212.hi.png)
---------------------------------------|--------------------------------------------
मानव तंत्रिका प्रणाली की सरलीकृत संरचना | ज्ञान-आधारित प्रणाली की संरचना

विशेषज्ञ प्रणाली मानव तर्क प्रणाली की तरह बनाई जाती हैं, जिसमें **अल्पकालिक स्मृति** और **दीर्घकालिक स्मृति** होती है। इसी तरह, ज्ञान-आधारित प्रणालियों में हम निम्नलिखित घटकों को अलग करते हैं:

* **समस्या स्मृति**: वर्तमान में हल की जा रही समस्या के बारे में ज्ञान रखती है, जैसे कि मरीज का तापमान या रक्तचाप, क्या उसे सूजन है या नहीं, आदि। इस ज्ञान को **स्थिर ज्ञान** भी कहा जाता है, क्योंकि इसमें समस्या के बारे में वर्तमान में ज्ञात चीजों का स्नैपशॉट होता है - जिसे *समस्या स्थिति* कहा जाता है।
* **ज्ञान आधार**: समस्या क्षेत्र के बारे में दीर्घकालिक ज्ञान का प्रतिनिधित्व करता है। इसे मानव विशेषज्ञों से मैन्युअल रूप से निकाला जाता है, और परामर्श से परामर्श तक नहीं बदलता। क्योंकि यह हमें एक समस्या स्थिति से दूसरी में नेविगेट करने की अनुमति देता है, इसे **गतिशील ज्ञान** भी कहा जाता है।
* **तर्क इंजन**: समस्या स्थिति स्थान में खोज प्रक्रिया को व्यवस्थित करता है, जब आवश्यक हो तो उपयोगकर्ता से प्रश्न पूछता है। यह प्रत्येक स्थिति पर लागू होने वाले सही नियमों को खोजने के लिए भी जिम्मेदार है।

उदाहरण के लिए, आइए एक जानवर की शारीरिक विशेषताओं के आधार पर उसे निर्धारित करने वाली विशेषज्ञ प्रणाली पर विचार करें:

![AND-OR ट्री](../../../../translated_images/AND-OR-Tree.5592d2c70187f283703c8e9c0d69d6a786eb370f4ace67f9a7aae5ada3d260b0.hi.png)

> छवि [Dmitry Soshnikov](http://soshnikov.com) द्वारा

इस आरेख को **AND-OR ट्री** कहा जाता है, और यह उत्पादन नियमों के सेट का ग्राफिकल प्रतिनिधित्व है। विशेषज्ञ से ज्ञान निकालने की शुरुआत में ट्री बनाना उपयोगी होता है। कंप्यूटर के अंदर ज्ञान को प्रस्तुत करने के लिए नियमों का उपयोग करना अधिक सुविधाजनक होता है:

```
IF the animal eats meat
OR (animal has sharp teeth
    AND animal has claws
    AND animal has forward-looking eyes
) 
THEN the animal is a carnivore
```

आप देख सकते हैं कि नियम के बाईं ओर की स्थिति और क्रिया वस्तु-एट्रिब्यूट-वैल्यू (OAV) ट्रिपलेट्स हैं। **कार्यशील स्मृति** उन OAV ट्रिपलेट्स का सेट रखती है जो वर्तमान में हल की जा रही समस्या से संबंधित हैं। **नियम इंजन** उन नियमों की खोज करता है जिनकी स्थिति संतुष्ट होती है और उन्हें लागू करता है, कार्यशील स्मृति में एक और ट्रिपलेट जोड़ता है।

> ✅ अपने पसंदीदा विषय पर अपना AND-OR ट्री बनाएं!

### फॉरवर्ड बनाम बैकवर्ड तर्क

ऊपर वर्णित प्रक्रिया को **फॉरवर्ड तर्क** कहा जाता है। यह कार्यशील स्मृति में समस्या के बारे में कुछ प्रारंभिक डेटा के साथ शुरू होता है, और फिर निम्नलिखित तर्क चक्र को निष्पादित करता है:

1. यदि लक्ष्य विशेषता कार्यशील स्मृति में मौजूद है - रुकें और परिणाम दें
2. उन सभी नियमों की खोज करें जिनकी स्थिति वर्तमान में संतुष्ट है - **संघर्ष सेट** प्राप्त करें।
3. **संघर्ष समाधान** करें - उस नियम का चयन करें जिसे इस चरण में निष्पादित किया जाएगा। विभिन्न संघर्ष समाधान रणनीतियाँ हो सकती हैं:
   - ज्ञान आधार में पहला लागू नियम चुनें
   - एक यादृच्छिक नियम चुनें
   - *अधिक विशिष्ट* नियम चुनें, यानी वह जो "बाईं ओर" (LHS) में सबसे अधिक स्थितियों को पूरा करता है
4. चयनित नियम लागू करें और समस्या स्थिति में नया ज्ञान जोड़ें
5. चरण 1 से पुनः आरंभ करें।

हालांकि, कुछ मामलों में हम समस्या के बारे में खाली ज्ञान के साथ शुरू करना चाहते हैं, और ऐसे प्रश्न पूछना चाहते हैं जो हमें निष्कर्ष तक पहुँचने में मदद करें। उदाहरण के लिए, जब चिकित्सा निदान करते हैं, तो हम आमतौर पर सभी चिकित्सा विश्लेषण पहले से नहीं करते हैं। हम निर्णय लेने की आवश्यकता होने पर विश्लेषण करना चाहते हैं।

इस प्रक्रिया को **बैकवर्ड तर्क** का उपयोग करके मॉडल किया जा सकता है। यह **लक्ष्य** द्वारा संचालित होता है - वह विशेषता मान जिसे हम खोजने की कोशिश कर रहे हैं:

1. उन सभी नियमों का चयन करें जो हमें लक्ष्य का मान दे सकते हैं (यानी लक्ष्य RHS ("दाईं ओर") पर हो) - एक संघर्ष सेट
1. यदि इस विशेषता के लिए कोई नियम नहीं है, या कोई नियम है जो कहता है कि हमें उपयोगकर्ता से मान पूछना चाहिए - पूछें, अन्यथा:
1. संघर्ष समाधान रणनीति का उपयोग करके एक नियम का चयन करें जिसे हम *परिकल्पना* के रूप में उपयोग करेंगे - हम इसे साबित करने की कोशिश करेंगे
1. नियम के LHS में सभी विशेषताओं के लिए प्रक्रिया को पुनरावर्ती रूप से दोहराएं, उन्हें लक्ष्य के रूप में साबित करने की कोशिश करें
1. यदि किसी भी बिंदु पर प्रक्रिया विफल हो जाती है - चरण 3 पर दूसरा नियम उपयोग करें।

> ✅ किन स्थितियों में फॉरवर्ड तर्क अधिक उपयुक्त है? और बैकवर्ड तर्क?

### विशेषज्ञ प्रणाली को लागू करना

विशेषज्ञ प्रणाली को विभिन्न उपकरणों का उपयोग करके लागू किया जा सकता है:

* उन्हें सीधे किसी उच्च स्तरीय प्रोग्रामिंग भाषा में प्रोग्राम करना। यह सबसे अच्छा विचार नहीं है, क्योंकि ज्ञान-आधारित प्रणाली का मुख्य लाभ यह है कि ज्ञान तर्क से अलग होता है, और संभावित रूप से समस्या क्षेत्र विशेषज्ञ को नियम लिखने में सक्षम होना चाहिए बिना तर्क प्रक्रिया के विवरण को समझे।
* **विशेषज्ञ प्रणाली शेल** का उपयोग करना, यानी एक प्रणाली जिसे विशेष रूप से किसी ज्ञान प्रतिनिधित्व भाषा का उपयोग करके ज्ञान से भरा जा सकता है।

## ✍️ अभ्यास: जानवर तर्क

[Animals.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/Animals.ipynb) देखें, जिसमें फॉरवर्ड और बैकवर्ड तर्क विशेषज्ञ प्रणाली को लागू करने का उदाहरण दिया गया है।

> **नोट**: यह उदाहरण काफी सरल है, और केवल यह विचार देता है कि विशेषज्ञ प्रणाली कैसी दिखती है। एक बार जब आप ऐसी प्रणाली बनाना शुरू करते हैं, तो आप केवल तभी *बुद्धिमान* व्यवहार देखेंगे जब आप लगभग 200+ नियमों तक पहुँचेंगे। एक बिंदु पर, नियम इतने जटिल हो जाते हैं कि सभी को याद रखना मुश्किल हो जाता है, और इस बिंदु पर आप सोच सकते हैं कि प्रणाली ने कुछ निर्णय क्यों लिए। हालांकि, ज्ञान-आधारित प्रणाली की महत्वपूर्ण विशेषता यह है कि आप हमेशा *समझा सकते हैं* कि किसी भी निर्णय को कैसे लिया गया।

## ओन्टोलॉजी और सामांतिक वेब

20वीं सदी के अंत में इंटरनेट संसाधनों को एनोटेट करने के लिए ज्ञान प्रतिनिधित्व का उपयोग करने की पहल की गई थी, ताकि बहुत विशिष्ट प्रश्नों के अनुरूप संसाधनों को ढूंढना संभव हो सके। इस आंदोलन को **सामांतिक वेब** कहा गया, और यह कई अवधारणाओं पर आधारित था:

- **[वर्णनात्मक तर्क](https://en.wikipedia.org/wiki/Description_logic)** (DL) पर आधारित एक विशेष ज्ञान प्रतिनिधित्व। यह फ्रेम ज्ञान प्रतिनिधित्व के समान है, क्योंकि यह गुणों के साथ वस्तुओं का पदानुक्रम बनाता है, लेकिन इसमें औपचारिक तर्कात्मक अर्थ और तर्क होता है। DL का एक पूरा परिवार है जो अभिव्यक्तता और तर्क की एल्गोरिदमिक जटिलता के बीच संतुलन बनाता है।
- वितरित ज्ञान प्रतिनिधित्व, जहाँ सभी अवधारणाओं को एक वैश्विक URI पहचानकर्ता द्वारा प्रस्तुत किया जाता है, जिससे इंटरनेट पर फैले ज्ञान पदानुक्रम बनाना संभव हो जाता है।
- ज्ञान वर्णन के लिए XML-आधारित भाषाओं का एक परिवार: RDF (Resource Description Framework), RDFS (RDF Schema), OWL (Ontology Web Language)।

सेमांटिक वेब का एक मुख्य विचार **ऑन्टोलॉजी** का है। यह किसी समस्या क्षेत्र का स्पष्ट विनिर्देशन है, जिसे औपचारिक ज्ञान प्रतिनिधित्व के माध्यम से व्यक्त किया जाता है। सबसे सरल ऑन्टोलॉजी केवल समस्या क्षेत्र में वस्तुओं की एक पदानुक्रम हो सकती है, लेकिन अधिक जटिल ऑन्टोलॉजी में ऐसे नियम शामिल होंगे जो निष्कर्ष निकालने के लिए उपयोग किए जा सकते हैं।

सेमांटिक वेब में, सभी प्रतिनिधित्व त्रिपलों पर आधारित होते हैं। प्रत्येक वस्तु और प्रत्येक संबंध को URI द्वारा अद्वितीय रूप से पहचाना जाता है। उदाहरण के लिए, यदि हम यह तथ्य बताना चाहते हैं कि यह AI पाठ्यक्रम Dmitry Soshnikov द्वारा 1 जनवरी, 2022 को विकसित किया गया है - तो यहां वे त्रिपल्स हैं जिन्हें हम उपयोग कर सकते हैं:

<img src="images/triplet.png" width="30%"/>

```
http://github.com/microsoft/ai-for-beginners http://www.example.com/terms/creation-date “Jan 13, 2007”
http://github.com/microsoft/ai-for-beginners http://purl.org/dc/elements/1.1/creator http://soshnikov.com
```

> ✅ यहां `http://www.example.com/terms/creation-date` और `http://purl.org/dc/elements/1.1/creator` कुछ प्रसिद्ध और सार्वभौमिक रूप से स्वीकृत URIs हैं जो *creator* और *creation date* की अवधारणाओं को व्यक्त करते हैं।

एक अधिक जटिल मामले में, यदि हम रचनाकारों की एक सूची को परिभाषित करना चाहते हैं, तो हम RDF में परिभाषित कुछ डेटा संरचनाओं का उपयोग कर सकते हैं।

<img src="images/triplet-complex.png" width="40%"/>

> ऊपर के आरेख [Dmitry Soshnikov](http://soshnikov.com) द्वारा।

सेमांटिक वेब के निर्माण की प्रगति को खोज इंजन और प्राकृतिक भाषा प्रसंस्करण तकनीकों की सफलता ने धीमा कर दिया, जो पाठ से संरचित डेटा निकालने की अनुमति देती हैं। हालांकि, कुछ क्षेत्रों में अभी भी ऑन्टोलॉजी और ज्ञान आधार बनाए रखने के लिए महत्वपूर्ण प्रयास किए जा रहे हैं। कुछ उल्लेखनीय परियोजनाएं:

* [WikiData](https://wikidata.org/) मशीन-पढ़ने योग्य ज्ञान आधारों का संग्रह है जो Wikipedia से जुड़ा हुआ है। अधिकांश डेटा Wikipedia *InfoBoxes* से निकाला गया है, जो Wikipedia पृष्ठों के अंदर संरचित सामग्री के टुकड़े हैं। आप [SPARQL](https://query.wikidata.org/) में WikiData को क्वेरी कर सकते हैं, जो सेमांटिक वेब के लिए एक विशेष क्वेरी भाषा है। यहां एक नमूना क्वेरी है जो मनुष्यों के बीच सबसे लोकप्रिय आंखों के रंग दिखाती है:

```sparql
#defaultView:BubbleChart
SELECT ?eyeColorLabel (COUNT(?human) AS ?count)
WHERE
{
  ?human wdt:P31 wd:Q5.       # human instance-of homo sapiens
  ?human wdt:P1340 ?eyeColor. # human eye-color ?eyeColor
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
GROUP BY ?eyeColorLabel
```

* [DBpedia](https://www.dbpedia.org/) WikiData के समान एक अन्य प्रयास है।

> ✅ यदि आप अपनी खुद की ऑन्टोलॉजी बनाने या मौजूदा ऑन्टोलॉजी खोलने के साथ प्रयोग करना चाहते हैं, तो एक शानदार दृश्य ऑन्टोलॉजी संपादक [Protégé](https://protege.stanford.edu/) है। इसे डाउनलोड करें, या इसे ऑनलाइन उपयोग करें।

<img src="images/protege.png" width="70%"/>

*वेब Protégé संपादक Romanov Family ऑन्टोलॉजी के साथ खुला। Dmitry Soshnikov द्वारा स्क्रीनशॉट*

## ✍️ अभ्यास: एक परिवार ऑन्टोलॉजी

[FamilyOntology.ipynb](https://github.com/Ezana135/AI-For-Beginners/blob/main/lessons/2-Symbolic/FamilyOntology.ipynb) देखें, जो सेमांटिक वेब तकनीकों का उपयोग करके पारिवारिक संबंधों के बारे में तर्क करने का एक उदाहरण है। हम सामान्य GEDCOM प्रारूप में प्रस्तुत एक परिवार वृक्ष और पारिवारिक संबंधों की एक ऑन्टोलॉजी लेंगे और दिए गए व्यक्तियों के सेट के लिए सभी पारिवारिक संबंधों का एक ग्राफ बनाएंगे।

## Microsoft Concept Graph

अधिकांश मामलों में, ऑन्टोलॉजी को सावधानीपूर्वक हाथ से बनाया जाता है। हालांकि, यह भी संभव है कि **अनौपचारिक डेटा** से ऑन्टोलॉजी निकाली जाएं, उदाहरण के लिए, प्राकृतिक भाषा पाठों से।

Microsoft Research द्वारा ऐसा ही एक प्रयास किया गया था, जिसके परिणामस्वरूप [Microsoft Concept Graph](https://blogs.microsoft.com/ai/microsoft-researchers-release-graph-that-helps-machines-conceptualize/?WT.mc_id=academic-77998-cacaste) बना।

यह `is-a` उत्तराधिकार संबंध का उपयोग करके समूहित संस्थाओं का एक बड़ा संग्रह है। यह "Microsoft क्या है?" जैसे प्रश्नों का उत्तर देने की अनुमति देता है - उत्तर कुछ इस प्रकार हो सकता है "एक कंपनी 0.87 संभावना के साथ, और एक ब्रांड 0.75 संभावना के साथ।"

ग्राफ़ REST API के रूप में उपलब्ध है, या एक बड़े डाउनलोड करने योग्य टेक्स्ट फ़ाइल के रूप में जो सभी इकाई जोड़े सूचीबद्ध करता है।

## ✍️ अभ्यास: एक कॉन्सेप्ट ग्राफ़

[MSConceptGraph.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/MSConceptGraph.ipynb) नोटबुक आज़माएं, यह देखने के लिए कि हम Microsoft Concept Graph का उपयोग करके समाचार लेखों को कई श्रेणियों में कैसे समूहित कर सकते हैं।

## निष्कर्ष

आजकल, AI को अक्सर *मशीन लर्निंग* या *न्यूरल नेटवर्क्स* का पर्याय माना जाता है। हालांकि, एक मानव भी स्पष्ट तर्क प्रदर्शित करता है, जो कुछ ऐसा है जिसे वर्तमान में न्यूरल नेटवर्क द्वारा संभाला नहीं जा रहा है। वास्तविक दुनिया की परियोजनाओं में, स्पष्ट तर्क अभी भी उन कार्यों को करने के लिए उपयोग किया जाता है जिनमें स्पष्टीकरण की आवश्यकता होती है, या सिस्टम के व्यवहार को नियंत्रित तरीके से संशोधित करने की क्षमता होती है।

## 🚀 चुनौती

इस पाठ से जुड़े Family Ontology नोटबुक में, अन्य पारिवारिक संबंधों के साथ प्रयोग करने का अवसर है। परिवार वृक्ष में लोगों के बीच नए संबंध खोजने का प्रयास करें।

## [पाठ के बाद क्विज़](https://ff-quizzes.netlify.app/en/ai/quiz/4)

## समीक्षा और स्व-अध्ययन

इंटरनेट पर शोध करें और उन क्षेत्रों की खोज करें जहां मनुष्यों ने ज्ञान को मापने और कोडिफाई करने का प्रयास किया है। Bloom's Taxonomy पर एक नज़र डालें, और इतिहास में वापस जाएं यह जानने के लिए कि मनुष्यों ने अपनी दुनिया को समझने की कोशिश कैसे की। Linnaeus के कार्य का अन्वेषण करें, जिन्होंने जीवों की एक वर्गीकरण प्रणाली बनाई, और Dmitri Mendeleev के कार्य को देखें, जिन्होंने रासायनिक तत्वों को वर्णित और समूहित करने का एक तरीका बनाया। आप कौन से अन्य दिलचस्प उदाहरण खोज सकते हैं?

**असाइनमेंट**: [ऑन्टोलॉजी बनाएं](assignment.md)

---

