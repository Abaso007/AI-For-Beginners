<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "ae074cd940fc2f4dc24fc07b66ccbd99",
  "translation_date": "2025-08-24T10:33:40+00:00",
  "source_file": "lessons/4-ComputerVision/08-TransferLearning/TrainingTricks.md",
  "language_code": "fa"
}
-->
# ترفندهای آموزش یادگیری عمیق

با عمیق‌تر شدن شبکه‌های عصبی، فرآیند آموزش آن‌ها چالش‌برانگیزتر می‌شود. یکی از مشکلات اصلی، مسئله‌ی [گرادیان‌های ناپدیدشونده](https://en.wikipedia.org/wiki/Vanishing_gradient_problem) یا [گرادیان‌های انفجاری](https://deepai.org/machine-learning-glossary-and-terms/exploding-gradient-problem#:~:text=Exploding%20gradients%20are%20a%20problem,updates%20are%20small%20and%20controlled.) است. [این مطلب](https://towardsdatascience.com/the-vanishing-exploding-gradient-problem-in-deep-neural-networks-191358470c11) مقدمه‌ی خوبی برای این مشکلات ارائه می‌دهد.

برای کارآمدتر کردن آموزش شبکه‌های عمیق، چند تکنیک وجود دارد که می‌توان از آن‌ها استفاده کرد.

## نگه داشتن مقادیر در بازه‌ی معقول

برای پایدارتر کردن محاسبات عددی، باید مطمئن شویم که تمام مقادیر درون شبکه‌ی عصبی ما در مقیاس معقولی قرار دارند، معمولاً [-1..1] یا [0..1]. این یک الزام خیلی سخت نیست، اما ماهیت محاسبات اعداد اعشاری به گونه‌ای است که مقادیر با مرتبه‌های بزرگی متفاوت نمی‌توانند به‌طور دقیق با هم ترکیب شوند. به عنوان مثال، اگر 10<sup>-10</sup> و 10<sup>10</sup> را با هم جمع کنیم، احتمالاً نتیجه 10<sup>10</sup> خواهد بود، زیرا مقدار کوچکتر به همان مرتبه‌ی مقدار بزرگتر "تبدیل" می‌شود و بنابراین مانتیسا از دست می‌رود.

بیشتر توابع فعال‌سازی در بازه‌ی [-1..1] غیرخطی هستند، بنابراین منطقی است که تمام داده‌های ورودی را به بازه‌ی [-1..1] یا [0..1] مقیاس‌بندی کنیم.

## مقداردهی اولیه‌ی وزن‌ها

به‌طور ایده‌آل، می‌خواهیم مقادیر پس از عبور از لایه‌های شبکه در همان بازه باقی بمانند. بنابراین، مهم است که وزن‌ها را به گونه‌ای مقداردهی کنیم که توزیع مقادیر حفظ شود.

توزیع نرمال **N(0,1)** ایده‌ی خوبی نیست، زیرا اگر *n* ورودی داشته باشیم، انحراف معیار خروجی *n* خواهد بود و مقادیر احتمالاً از بازه‌ی [0..1] خارج می‌شوند.

مقداردهی‌های اولیه‌ی زیر اغلب استفاده می‌شوند:

- توزیع یکنواخت -- `uniform`
- **N(0,1/n)** -- `gaussian`
- **N(0,1/√n_in)** تضمین می‌کند که برای ورودی‌هایی با میانگین صفر و انحراف معیار 1، همان میانگین/انحراف معیار باقی می‌ماند.
- **N(0,√2/(n_in+n_out))** -- به اصطلاح **مقداردهی اولیه‌ی Xavier** (`glorot`)، که به حفظ سیگنال‌ها در بازه در طول پیش‌رو و پس‌رو کمک می‌کند.

## نرمال‌سازی دسته‌ای

حتی با مقداردهی اولیه‌ی مناسب وزن‌ها، وزن‌ها می‌توانند در طول آموزش به‌طور دلخواه بزرگ یا کوچک شوند و سیگنال‌ها را از بازه‌ی مناسب خارج کنند. می‌توانیم سیگنال‌ها را با استفاده از یکی از تکنیک‌های **نرمال‌سازی** به بازه‌ی مناسب بازگردانیم. در حالی که چندین تکنیک وجود دارد (نرمال‌سازی وزن، نرمال‌سازی لایه‌ای)، نرمال‌سازی دسته‌ای بیشتر مورد استفاده قرار می‌گیرد.

ایده‌ی **نرمال‌سازی دسته‌ای** این است که تمام مقادیر در سراسر مینی‌بچ را در نظر بگیریم و نرمال‌سازی (یعنی کم کردن میانگین و تقسیم بر انحراف معیار) را بر اساس آن مقادیر انجام دهیم. این تکنیک به‌صورت یک لایه‌ی شبکه پیاده‌سازی می‌شود که این نرمال‌سازی را پس از اعمال وزن‌ها و قبل از تابع فعال‌سازی انجام می‌دهد. نتیجه‌ی آن، دقت نهایی بالاتر و آموزش سریع‌تر است.

[مقاله‌ی اصلی](https://arxiv.org/pdf/1502.03167.pdf) درباره‌ی نرمال‌سازی دسته‌ای، [توضیح در ویکی‌پدیا](https://en.wikipedia.org/wiki/Batch_normalization)، و [یک پست وبلاگی مقدماتی خوب](https://towardsdatascience.com/batch-normalization-in-3-levels-of-understanding-14c2da90a338) (و یکی [به زبان روسی](https://habrahabr.ru/post/309302/)) را می‌توانید مطالعه کنید.

## دراپ‌آوت

**دراپ‌آوت** یک تکنیک جالب است که درصد مشخصی از نورون‌های تصادفی را در طول آموزش حذف می‌کند. این تکنیک به‌صورت یک لایه با یک پارامتر (درصد نورون‌هایی که باید حذف شوند، معمولاً 10%-50%) پیاده‌سازی می‌شود و در طول آموزش، عناصر تصادفی بردار ورودی را صفر می‌کند، قبل از اینکه آن را به لایه‌ی بعدی ارسال کند.

اگرچه این ایده ممکن است عجیب به نظر برسد، می‌توانید اثر دراپ‌آوت را در آموزش یک طبقه‌بند ارقام MNIST در دفترچه‌ی [`Dropout.ipynb`](../../../../../lessons/4-ComputerVision/08-TransferLearning/Dropout.ipynb) مشاهده کنید. این تکنیک سرعت آموزش را افزایش می‌دهد و به ما اجازه می‌دهد در تعداد کمتری از دوره‌های آموزشی به دقت بالاتری دست یابیم.

این اثر را می‌توان به چند روش توضیح داد:

- می‌توان آن را به‌عنوان یک عامل شوک تصادفی به مدل در نظر گرفت که بهینه‌سازی را از حداقل محلی خارج می‌کند.
- می‌توان آن را به‌عنوان *میانگین‌گیری ضمنی مدل* در نظر گرفت، زیرا می‌توان گفت که در طول دراپ‌آوت، ما در حال آموزش مدل‌های کمی متفاوت هستیم.

> *برخی افراد می‌گویند وقتی یک فرد مست سعی می‌کند چیزی یاد بگیرد، صبح روز بعد بهتر آن را به خاطر می‌آورد، در مقایسه با یک فرد هوشیار، زیرا مغزی با برخی نورون‌های معیوب سعی می‌کند بهتر خود را برای درک مفهوم تطبیق دهد. ما هرگز خودمان این موضوع را آزمایش نکرده‌ایم که آیا درست است یا نه.*

## جلوگیری از بیش‌برازش

یکی از جنبه‌های بسیار مهم یادگیری عمیق، توانایی جلوگیری از [بیش‌برازش](../../3-NeuralNetworks/05-Frameworks/Overfitting.md) است. اگرچه ممکن است استفاده از یک مدل شبکه‌ی عصبی بسیار قدرتمند وسوسه‌انگیز باشد، اما همیشه باید تعداد پارامترهای مدل را با تعداد نمونه‌های آموزشی متعادل کنیم.

> مطمئن شوید که مفهوم [بیش‌برازش](../../3-NeuralNetworks/05-Frameworks/Overfitting.md) که قبلاً معرفی کرده‌ایم را درک کرده‌اید!

چندین روش برای جلوگیری از بیش‌برازش وجود دارد:

- توقف زودهنگام -- به‌طور مداوم خطا را روی مجموعه‌ی اعتبارسنجی نظارت کنید و زمانی که خطای اعتبارسنجی شروع به افزایش کرد، آموزش را متوقف کنید.
- کاهش وزن صریح / منظم‌سازی -- اضافه کردن یک جریمه‌ی اضافی به تابع خطا برای مقادیر مطلق بالای وزن‌ها، که از نتایج بسیار ناپایدار مدل جلوگیری می‌کند.
- میانگین‌گیری مدل -- آموزش چندین مدل و سپس میانگین‌گیری نتیجه. این کار به حداقل رساندن واریانس کمک می‌کند.
- دراپ‌آوت (میانگین‌گیری ضمنی مدل)

## بهینه‌سازها / الگوریتم‌های آموزشی

یکی دیگر از جنبه‌های مهم آموزش، انتخاب الگوریتم آموزشی مناسب است. اگرچه **گرادیان نزولی کلاسیک** یک انتخاب منطقی است، اما گاهی اوقات ممکن است خیلی کند باشد یا مشکلات دیگری ایجاد کند.

در یادگیری عمیق، از **گرادیان نزولی تصادفی** (SGD) استفاده می‌کنیم، که یک گرادیان نزولی است که روی مینی‌بچ‌های تصادفی انتخاب‌شده از مجموعه‌ی آموزشی اعمال می‌شود. وزن‌ها با استفاده از این فرمول تنظیم می‌شوند:

w<sup>t+1</sup> = w<sup>t</sup> - η∇ℒ

### مومنتوم

در **SGD مومنتوم**، بخشی از گرادیان مراحل قبلی را نگه می‌داریم. این شبیه به زمانی است که با اینرسی در حال حرکت هستیم و ضربه‌ای در جهت دیگری دریافت می‌کنیم؛ مسیر ما بلافاصله تغییر نمی‌کند، بلکه بخشی از حرکت اصلی را حفظ می‌کند. در اینجا یک بردار دیگر v را برای نشان دادن *سرعت* معرفی می‌کنیم:

- v<sup>t+1</sup> = γ v<sup>t</sup> - η∇ℒ
- w<sup>t+1</sup> = w<sup>t</sup>+v<sup>t+1</sup>

در اینجا پارامتر γ نشان می‌دهد که تا چه حد اینرسی را در نظر می‌گیریم: γ=0 معادل با SGD کلاسیک است؛ γ=1 یک معادله‌ی حرکت خالص است.

### Adam، Adagrad و غیره

از آنجا که در هر لایه سیگنال‌ها را در یک ماتریس W<sub>i</sub> ضرب می‌کنیم، بسته به ||W<sub>i</sub>||، گرادیان ممکن است یا کاهش یابد و به صفر نزدیک شود، یا به‌طور نامحدود افزایش یابد. این جوهره‌ی مشکل گرادیان‌های انفجاری/ناپدیدشونده است.

یکی از راه‌حل‌های این مشکل، استفاده از جهت گرادیان در معادله و نادیده گرفتن مقدار مطلق آن است، یعنی:

w<sup>t+1</sup> = w<sup>t</sup> - η(∇ℒ/||∇ℒ||)، که در آن ||∇ℒ|| = √∑(∇ℒ)<sup>2</sup>

این الگوریتم **Adagrad** نامیده می‌شود. الگوریتم‌های دیگری که از همین ایده استفاده می‌کنند: **RMSProp**، **Adam**

> **Adam** به‌عنوان یک الگوریتم بسیار کارآمد برای بسیاری از کاربردها در نظر گرفته می‌شود، بنابراین اگر مطمئن نیستید کدام را استفاده کنید - از Adam استفاده کنید.

### برش گرادیان

برش گرادیان گسترش ایده‌ی بالا است. وقتی ||∇ℒ|| ≤ θ، گرادیان اصلی را در بهینه‌سازی وزن در نظر می‌گیریم، و وقتی ||∇ℒ|| > θ - گرادیان را بر نُرم آن تقسیم می‌کنیم. در اینجا θ یک پارامتر است، در بیشتر موارد می‌توانیم θ=1 یا θ=10 را انتخاب کنیم.

### کاهش نرخ یادگیری

موفقیت آموزش اغلب به پارامتر نرخ یادگیری η بستگی دارد. منطقی است که فرض کنیم مقادیر بزرگتر η منجر به آموزش سریع‌تر می‌شوند، که چیزی است که معمولاً در ابتدای آموزش می‌خواهیم، و سپس مقادیر کوچکتر η به ما اجازه می‌دهند شبکه را به‌طور دقیق تنظیم کنیم. بنابراین، در بیشتر موارد می‌خواهیم η را در طول فرآیند آموزش کاهش دهیم.

این کار را می‌توان با ضرب کردن η در یک عدد (مثلاً 0.98) پس از هر دوره‌ی آموزشی انجام داد، یا با استفاده از یک **برنامه‌ی نرخ یادگیری** پیچیده‌تر.

## معماری‌های مختلف شبکه

انتخاب معماری مناسب شبکه برای مسئله‌ی شما می‌تواند دشوار باشد. معمولاً، معماری‌ای را انتخاب می‌کنیم که برای وظیفه‌ی خاص ما (یا مشابه آن) اثبات شده باشد. [این مرور خوب](https://www.topbots.com/a-brief-history-of-neural-network-architectures/) درباره‌ی معماری‌های شبکه‌های عصبی برای بینایی کامپیوتر را ببینید.

> مهم است که معماری‌ای را انتخاب کنید که به اندازه‌ی کافی قدرتمند باشد برای تعداد نمونه‌های آموزشی که داریم. انتخاب مدل بیش از حد قدرتمند می‌تواند منجر به [بیش‌برازش](../../3-NeuralNetworks/05-Frameworks/Overfitting.md) شود.

راه دیگر خوب این است که از معماری‌ای استفاده کنید که به‌طور خودکار با پیچیدگی مورد نیاز تنظیم شود. تا حدی، معماری **ResNet** و **Inception** خودتنظیم هستند. [اطلاعات بیشتر درباره‌ی معماری‌های بینایی کامپیوتر](../07-ConvNets/CNN_Architectures.md)

**سلب مسئولیت**:  
این سند با استفاده از سرویس ترجمه هوش مصنوعی [Co-op Translator](https://github.com/Azure/co-op-translator) ترجمه شده است. در حالی که ما تلاش می‌کنیم دقت را حفظ کنیم، لطفاً توجه داشته باشید که ترجمه‌های خودکار ممکن است حاوی خطاها یا نادرستی‌هایی باشند. سند اصلی به زبان اصلی آن باید به عنوان منبع معتبر در نظر گرفته شود. برای اطلاعات حساس، ترجمه حرفه‌ای انسانی توصیه می‌شود. ما هیچ مسئولیتی در قبال سوءتفاهم‌ها یا تفسیرهای نادرست ناشی از استفاده از این ترجمه نداریم.