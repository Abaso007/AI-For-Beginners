<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "98c5222ff9556b55223fed2337145e18",
  "translation_date": "2025-08-26T00:29:39+00:00",
  "source_file": "lessons/2-Symbolic/README.md",
  "language_code": "uk"
}
-->
# Представлення знань та експертні системи

![Резюме змісту про символічний AI](../../../../translated_images/ai-symbolic.715a30cb610411a6964d2e2f23f24364cb338a07cb4844c1f97084d366e586c3.uk.png)

> Скетчнот від [Tomomi Imura](https://twitter.com/girlie_mac)

Пошук штучного інтелекту базується на прагненні до знань, щоб зрозуміти світ так, як це роблять люди. Але як це можна реалізувати?

## [Тест перед лекцією](https://ff-quizzes.netlify.app/en/ai/quiz/3)

У ранні дні розвитку AI популярним був підхід "зверху вниз" до створення інтелектуальних систем (обговорювався в попередньому уроці). Ідея полягала в тому, щоб витягти знання від людей у машинозчитуваній формі, а потім використовувати їх для автоматичного вирішення проблем. Цей підхід базувався на двох великих ідеях:

* Представлення знань
* Міркування

## Представлення знань

Одним із важливих концептів у символічному AI є **знання**. Важливо відрізняти знання від *інформації* або *даних*. Наприклад, можна сказати, що книги містять знання, тому що їх можна вивчати і ставати експертом. Однак те, що міститься в книгах, насправді називається *даними*, і, читаючи книги та інтегруючи ці дані у нашу модель світу, ми перетворюємо дані на знання.

> ✅ **Знання** — це те, що міститься у нашій голові і представляє наше розуміння світу. Воно отримується через активний процес **навчання**, який інтегрує отриману інформацію у нашу активну модель світу.

Найчастіше ми не строго визначаємо знання, але співвідносимо їх з іншими пов'язаними концептами за допомогою [піраміди DIKW](https://en.wikipedia.org/wiki/DIKW_pyramid). Вона містить наступні концепти:

* **Дані** — це те, що представлено на фізичних носіях, таких як написаний текст або вимовлені слова. Дані існують незалежно від людей і можуть передаватися між ними.
* **Інформація** — це те, як ми інтерпретуємо дані у нашій голові. Наприклад, коли ми чуємо слово *комп'ютер*, ми маємо певне розуміння, що це таке.
* **Знання** — це інформація, інтегрована у нашу модель світу. Наприклад, коли ми дізнаємося, що таке комп'ютер, ми починаємо мати уявлення про те, як він працює, скільки коштує і для чого його можна використовувати. Ця мережа взаємопов'язаних концептів формує наші знання.
* **Мудрість** — це ще один рівень нашого розуміння світу, який представляє *мета-знання*, тобто уявлення про те, як і коли знання слід використовувати.

*Зображення [з Вікіпедії](https://commons.wikimedia.org/w/index.php?curid=37705247), By Longlivetheux - Own work, CC BY-SA 4.0*

Таким чином, проблема **представлення знань** полягає у пошуку ефективного способу представлення знань у комп'ютері у вигляді даних, щоб зробити їх автоматично використовуваними. Це можна розглядати як спектр:

![Спектр представлення знань](../../../../translated_images/knowledge-spectrum.b60df631852c0217e941485b79c9eee40ebd574f15f18609cec5758fcb384bf3.uk.png)

> Зображення від [Dmitry Soshnikov](http://soshnikov.com)

* Ліворуч знаходяться дуже прості типи представлення знань, які можуть ефективно використовуватися комп'ютерами. Найпростіший — алгоритмічний, коли знання представлені комп'ютерною програмою. Однак це не найкращий спосіб представлення знань, оскільки він не є гнучким. Знання у нашій голові часто не є алгоритмічними.
* Праворуч знаходяться представлення, такі як природний текст. Це найпотужніший спосіб, але він не може бути використаний для автоматичного міркування.

> ✅ Подумайте хвилину про те, як ви представляєте знання у своїй голові і перетворюєте їх на нотатки. Чи є якийсь формат, який добре працює для вас, щоб сприяти запам'ятовуванню?

## Класифікація комп'ютерних методів представлення знань

Ми можемо класифікувати різні методи представлення знань у комп'ютері за наступними категоріями:

* **Мережеві представлення** базуються на тому, що у нашій голові є мережа взаємопов'язаних концептів. Ми можемо спробувати відтворити такі ж мережі у вигляді графа у комп'ютері — так званої **семантичної мережі**.

1. **Трійки об'єкт-атрибут-значення** або **пари атрибут-значення**. Оскільки граф може бути представлений у комп'ютері як список вузлів і ребер, ми можемо представити семантичну мережу у вигляді списку трійок, що містять об'єкти, атрибути і значення. Наприклад, ми створюємо наступні трійки про мови програмування:

Об'єкт | Атрибут | Значення
-------|---------|---------
Python | є | Мова без типізації
Python | винайдений | Guido van Rossum
Python | синтаксис блоку | відступи
Мова без типізації | не має | визначень типів

> ✅ Подумайте, як трійки можуть бути використані для представлення інших типів знань.

2. **Ієрархічні представлення** підкреслюють той факт, що ми часто створюємо ієрархію об'єктів у нашій голові. Наприклад, ми знаємо, що канарка — це птах, і всі птахи мають крила. Ми також маємо уявлення про те, якого кольору зазвичай канарка і яка її швидкість польоту.

   - **Представлення у вигляді фреймів** базується на представленні кожного об'єкта або класу об'єктів як **фрейму**, який містить **слоти**. Слоти мають можливі значення за замовчуванням, обмеження значень або збережені процедури, які можна викликати для отримання значення слота. Усі фрейми формують ієрархію, схожу на ієрархію об'єктів у мовах програмування, орієнтованих на об'єкти.
   - **Сценарії** — це особливий вид фреймів, які представляють складні ситуації, що можуть розгортатися у часі.

**Python**

Слот | Значення | Значення за замовчуванням | Інтервал |
-----|----------|---------------------------|----------|
Назва | Python | | |
Є | Мова без типізації | | |
Стиль змінних | | CamelCase | |
Довжина програми | | | 5-5000 рядків |
Синтаксис блоку | Відступ | | |

3. **Процедурні представлення** базуються на представленні знань у вигляді списку дій, які можуть бути виконані за певних умов.
   - Правила продукції — це if-then твердження, які дозволяють робити висновки. Наприклад, лікар може мати правило, яке говорить, що **ЯКЩО** у пацієнта висока температура **АБО** високий рівень C-реактивного білка у аналізі крові **ТОДІ** у нього запалення. Як тільки ми стикаємося з однією з умов, ми можемо зробити висновок про запалення, а потім використовувати його у подальших міркуваннях.
   - Алгоритми можна вважати ще однією формою процедурного представлення, хоча вони майже ніколи не використовуються безпосередньо у системах, заснованих на знаннях.

4. **Логіка** була спочатку запропонована Арістотелем як спосіб представлення універсальних людських знань.
   - Логіка предикатів як математична теорія є занадто багатою, щоб бути обчислюваною, тому зазвичай використовується її підмножина, така як клаузи Хорна, що використовуються у Prolog.
   - Описова логіка — це сімейство логічних систем, які використовуються для представлення і міркування про ієрархії об'єктів у розподілених представленнях знань, таких як *семантична мережа*.

## Експертні системи

Одним із ранніх успіхів символічного AI були так звані **експертні системи** — комп'ютерні системи, які були розроблені для того, щоб діяти як експерт у певній обмеженій області проблем. Вони базувалися на **базі знань**, отриманій від одного або кількох людських експертів, і містили **мотор виведення**, який виконував певні міркування на її основі.

![Архітектура людини](../../../../translated_images/arch-human.5d4d35f1bba3ab1cdfda96af2f10b89574eb31e9796d0e3011cd9beda1c35112.uk.png) | ![Система, заснована на знаннях](../../../../translated_images/arch-kbs.3ec5c150b09fa8dadc2beb0931a4983c9e2b03913a89eebcc103b5bb841b0212.uk.png)
---------------------------------------------|------------------------------------------------
Спрощена структура людської нервової системи | Архітектура системи, заснованої на знаннях

Експертні системи побудовані як система людського мислення, яка містить **короткострокову пам'ять** і **довгострокову пам'ять**. Аналогічно, у системах, заснованих на знаннях, ми розрізняємо наступні компоненти:

* **Пам'ять проблеми**: містить знання про проблему, яка зараз вирішується, тобто температуру або кров'яний тиск пацієнта, чи є у нього запалення тощо. Ці знання також називаються **статичними знаннями**, оскільки вони містять знімок того, що ми зараз знаємо про проблему — так званий *стан проблеми*.
* **База знань**: представляє довгострокові знання про область проблеми. Вона отримується вручну від людських експертів і не змінюється від консультації до консультації. Оскільки вона дозволяє нам переходити від одного стану проблеми до іншого, її також називають **динамічними знаннями**.
* **Мотор виведення**: координує весь процес пошуку у просторі станів проблеми, задаючи питання користувачеві, коли це необхідно. Він також відповідає за пошук правильних правил, які слід застосувати до кожного стану.

Наприклад, розглянемо наступну експертну систему для визначення тварини на основі її фізичних характеристик:

![AND-OR дерево](../../../../translated_images/AND-OR-Tree.5592d2c70187f283703c8e9c0d69d6a786eb370f4ace67f9a7aae5ada3d260b0.uk.png)

> Зображення від [Dmitry Soshnikov](http://soshnikov.com)

Ця діаграма називається **AND-OR деревом**, і вона є графічним представленням набору правил продукції. Малювання дерева корисне на початку отримання знань від експерта. Для представлення знань у комп'ютері зручніше використовувати правила:

```
IF the animal eats meat
OR (animal has sharp teeth
    AND animal has claws
    AND animal has forward-looking eyes
) 
THEN the animal is a carnivore
```

Ви можете помітити, що кожна умова на лівій стороні правила і дія фактично є трійками об'єкт-атрибут-значення (OAV). **Робоча пам'ять** містить набір трійок OAV, які відповідають проблемі, що зараз вирішується. **Мотор правил** шукає правила, для яких умова задовольняється, і застосовує їх, додаючи ще одну трійку до робочої пам'яті.

> ✅ Намалюйте власне AND-OR дерево на тему, яка вам подобається!

### Пряме vs. зворотне виведення

Описаний вище процес називається **прямим виведенням**. Він починається з деяких початкових даних про проблему, доступних у робочій пам'яті, а потім виконує наступний цикл міркувань:

1. Якщо цільовий атрибут присутній у робочій пам'яті — зупинитися і надати результат
2. Шукати всі правила, умова яких зараз задовольняється — отримати **конфліктний набір** правил.
3. Виконати **розв'язання конфлікту** — вибрати одне правило, яке буде виконано на цьому кроці. Можуть бути різні стратегії розв'язання конфлікту:
   - Вибрати перше застосовне правило у базі знань
   - Вибрати випадкове правило
   - Вибрати *більш специфічне* правило, тобто те, яке задовольняє найбільше умов на "лівій стороні" (LHS)
4. Застосувати вибране правило і вставити новий шматок знань у стан проблеми
5. Повторити з кроку 1.

Однак у деяких випадках ми можемо захотіти почати з порожніх знань про проблему і задавати питання, які допоможуть нам дійти до висновку. Наприклад, при медичній діагностиці ми зазвичай не виконуємо всі медичні аналізи заздалегідь перед початком діагностики пацієнта. Ми скоріше хочемо виконувати аналізи, коли потрібно прийняти рішення.

Цей процес можна змоделювати за допомогою **зворотного виведення**. Він керується **ціллю** — значенням атрибута, яке ми шукаємо:

1. Вибрати всі правила, які можуть надати нам значення цілі (тобто з ціллю на RHS ("правій стороні")) — конфліктний набір
1. Якщо немає правил для цього атрибута або є правило, яке говорить, що ми повинні запитати значення у користувача — запитати його, інакше:
1. Використовувати стратегію розв'язання конфлікту, щоб вибрати одне правило, яке ми будемо використовувати як *гіпотезу* — ми спробуємо її довести
1. Рекурсивно повторити процес для всіх атрибутів на LHS правила, намагаючись довести їх як цілі
1. Якщо у будь-який момент процес зазнає невдачі — використовувати інше правило на кроці 3.

> ✅ У яких ситуаціях пряме виведення є більш доречним? А як щодо зворотного виведення?

### Реалізація експертних систем

Експертні системи можуть бути реалізовані за допомогою різних інструментів:

* Програмування їх безпосередньо у якійсь високорівневій мові програмування. Це не найкраща ідея, оскільки головна перевага системи, заснованої на знаннях, полягає у тому, що знання відокремлені від виведення, і потенційно експерт у проблемній області повинен мати можливість писати правила, не розуміючи деталей процесу виведення.
* Використання **оболонки експертних систем**, тобто системи, спеціально розробленої для заповнення знаннями за допомогою якоїсь мови представлення знань.

## ✍️ Вправа: Виведення про тварин

Дивіться [Animals.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/Animals.ipynb) для прикладу реалізації експертної системи з прямим і зворотним виведенням.
> **Примітка**: Цей приклад досить простий і лише дає уявлення про те, як виглядає експертна система. Коли ви почнете створювати таку систему, ви помітите *інтелектуальну* поведінку лише тоді, коли досягнете певної кількості правил, приблизно 200+. У якийсь момент правила стають занадто складними, щоб тримати всі їх у пам'яті, і саме тоді ви можете почати замислюватися, чому система приймає певні рішення. Однак важливою характеристикою систем, заснованих на знаннях, є те, що ви завжди можете *пояснити*, як саме було прийнято будь-яке з рішень.
## Онтології та Семантична павутина

Наприкінці 20-го століття була ініціатива використати представлення знань для анотування ресурсів Інтернету, щоб можна було знаходити ресурси, які відповідають дуже специфічним запитам. Цей рух називався **Семантична павутина**, і він базувався на кількох концепціях:

- Спеціальне представлення знань, засноване на **[логіці описів](https://en.wikipedia.org/wiki/Description_logic)** (DL). Воно схоже на представлення знань у рамках, оскільки будує ієрархію об'єктів із властивостями, але має формальну логічну семантику та висновки. Існує ціла родина DL, яка балансує між виразністю та алгоритмічною складністю висновків.
- Розподілене представлення знань, де всі концепції представлені глобальним ідентифікатором URI, що дозволяє створювати ієрархії знань, які охоплюють Інтернет.
- Родина мов на основі XML для опису знань: RDF (Resource Description Framework), RDFS (RDF Schema), OWL (Ontology Web Language).

Основною концепцією в Семантичній павутині є концепція **Онтології**. Вона стосується явної специфікації предметної області за допомогою формального представлення знань. Найпростіша онтологія може бути просто ієрархією об'єктів у предметній області, але складніші онтології включатимуть правила, які можна використовувати для висновків.

У Семантичній павутині всі представлення базуються на трійках. Кожен об'єкт і кожне відношення унікально ідентифікуються URI. Наприклад, якщо ми хочемо заявити факт, що цей навчальний план з AI був розроблений Дмитром Сошниковим 1 січня 2022 року, ось трійки, які ми можемо використати:

<img src="images/triplet.png" width="30%"/>

```
http://github.com/microsoft/ai-for-beginners http://www.example.com/terms/creation-date “Jan 13, 2007”
http://github.com/microsoft/ai-for-beginners http://purl.org/dc/elements/1.1/creator http://soshnikov.com
```

> ✅ Тут `http://www.example.com/terms/creation-date` і `http://purl.org/dc/elements/1.1/creator` — це деякі загальновідомі та універсально прийняті URI для вираження концепцій *автора* та *дати створення*.

У більш складному випадку, якщо ми хочемо визначити список авторів, ми можемо використати деякі структури даних, визначені в RDF.

<img src="images/triplet-complex.png" width="40%"/>

> Діаграми вище створені [Дмитром Сошниковим](http://soshnikov.com)

Прогрес у створенні Семантичної павутини був дещо уповільнений через успіх пошукових систем і методів обробки природної мови, які дозволяють витягувати структуровані дані з тексту. Однак у деяких областях все ще докладаються значні зусилля для підтримки онтологій і баз знань. Кілька проектів, які варто відзначити:

* [WikiData](https://wikidata.org/) — це колекція машинозчитуваних баз знань, пов'язаних із Вікіпедією. Більшість даних добувається з *InfoBoxes* Вікіпедії, шматків структурованого контенту всередині сторінок Вікіпедії. Ви можете [запитувати](https://query.wikidata.org/) WikiData за допомогою SPARQL, спеціальної мови запитів для Семантичної павутини. Ось приклад запиту, який показує найпоширеніші кольори очей серед людей:

```sparql
#defaultView:BubbleChart
SELECT ?eyeColorLabel (COUNT(?human) AS ?count)
WHERE
{
  ?human wdt:P31 wd:Q5.       # human instance-of homo sapiens
  ?human wdt:P1340 ?eyeColor. # human eye-color ?eyeColor
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
GROUP BY ?eyeColorLabel
```

* [DBpedia](https://www.dbpedia.org/) — ще одна ініціатива, схожа на WikiData.

> ✅ Якщо ви хочете експериментувати зі створенням власних онтологій або відкриттям існуючих, є чудовий візуальний редактор онтологій під назвою [Protégé](https://protege.stanford.edu/). Завантажте його або використовуйте онлайн.

<img src="images/protege.png" width="70%"/>

*Веб-редактор Protégé відкритий із онтологією родини Романових. Скриншот Дмитра Сошникова*

## ✍️ Вправа: Онтологія родини

Дивіться [FamilyOntology.ipynb](https://github.com/Ezana135/AI-For-Beginners/blob/main/lessons/2-Symbolic/FamilyOntology.ipynb) для прикладу використання технік Семантичної павутини для аналізу сімейних відносин. Ми візьмемо родинне дерево, представлене у форматі GEDCOM, і онтологію сімейних відносин, щоб побудувати граф усіх сімейних відносин для заданого набору осіб.

## Граф концепцій Microsoft

У більшості випадків онтології ретельно створюються вручну. Однак також можливо **добувати** онтології з неструктурованих даних, наприклад, із текстів природної мови.

Одна з таких спроб була здійснена Microsoft Research і призвела до створення [Microsoft Concept Graph](https://blogs.microsoft.com/ai/microsoft-researchers-release-graph-that-helps-machines-conceptualize/?WT.mc_id=academic-77998-cacaste).

Це велика колекція сутностей, згрупованих за допомогою відношення успадкування `is-a`. Вона дозволяє відповідати на запитання типу "Що таке Microsoft?" — відповідь буде щось на кшталт "компанія з ймовірністю 0.87 і бренд з ймовірністю 0.75".

Граф доступний як REST API або як великий текстовий файл для завантаження, який містить усі пари сутностей.

## ✍️ Вправа: Граф концепцій

Спробуйте [MSConceptGraph.ipynb](https://github.com/microsoft/AI-For-Beginners/blob/main/lessons/2-Symbolic/MSConceptGraph.ipynb) блокнот, щоб побачити, як ми можемо використовувати Microsoft Concept Graph для групування новинних статей у кілька категорій.

## Висновок

Сьогодні AI часто вважається синонімом *машинного навчання* або *нейронних мереж*. Однак людина також демонструє явне мислення, яке наразі не обробляється нейронними мережами. У реальних проектах явне мислення все ще використовується для виконання завдань, які потребують пояснень або можливості змінювати поведінку системи контрольованим чином.

## 🚀 Виклик

У блокноті Family Ontology, пов'язаному з цим уроком, є можливість експериментувати з іншими сімейними відносинами. Спробуйте знайти нові зв'язки між людьми в родинному дереві.

## [Тест після лекції](https://ff-quizzes.netlify.app/en/ai/quiz/4)

## Огляд і самостійне навчання

Проведіть дослідження в Інтернеті, щоб виявити області, де люди намагалися кількісно оцінити та кодувати знання. Ознайомтеся з таксономією Блума та поверніться в історію, щоб дізнатися, як люди намагалися зрозуміти свій світ. Досліджуйте роботу Ліннея зі створення таксономії організмів і спостерігайте, як Дмитро Менделєєв створив спосіб опису та групування хімічних елементів. Які інші цікаві приклади ви можете знайти?

**Завдання**: [Створіть онтологію](assignment.md)

**Відмова від відповідальності**:  
Цей документ був перекладений за допомогою сервісу автоматичного перекладу [Co-op Translator](https://github.com/Azure/co-op-translator). Хоча ми прагнемо до точності, будь ласка, майте на увазі, що автоматичні переклади можуть містити помилки або неточності. Оригінальний документ на його рідній мові слід вважати авторитетним джерелом. Для критичної інформації рекомендується професійний людський переклад. Ми не несемо відповідальності за будь-які непорозуміння або неправильні тлумачення, що виникають внаслідок використання цього перекладу.