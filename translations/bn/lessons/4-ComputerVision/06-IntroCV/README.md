<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "4bedc8e702db17260cfe824d58b6cfd4",
  "translation_date": "2025-08-26T09:36:35+00:00",
  "source_file": "lessons/4-ComputerVision/06-IntroCV/README.md",
  "language_code": "bn"
}
-->
# কম্পিউটার ভিশনের পরিচিতি

[কম্পিউটার ভিশন](https://wikipedia.org/wiki/Computer_vision) এমন একটি শাখা যা কম্পিউটারকে ডিজিটাল ইমেজ থেকে উচ্চ-স্তরের বোঝাপড়া অর্জন করতে সক্ষম করে। এটি একটি বিস্তৃত সংজ্ঞা, কারণ *বোঝাপড়া* বিভিন্ন অর্থ বহন করতে পারে, যেমন একটি ছবিতে কোনো বস্তু খুঁজে বের করা (**অবজেক্ট ডিটেকশন**), কী ঘটছে তা বোঝা (**ইভেন্ট ডিটেকশন**), ছবিকে টেক্সটে বর্ণনা করা, অথবা ৩ডি-তে একটি দৃশ্য পুনর্গঠন করা। মানুষের ছবি সম্পর্কিত বিশেষ কিছু কাজও রয়েছে: বয়স এবং আবেগ নির্ধারণ, মুখ সনাক্তকরণ এবং শনাক্তকরণ, এবং ৩ডি পোজ নির্ধারণ, ইত্যাদি।

## [পূর্ব-লেকচার কুইজ](https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/106)

কম্পিউটার ভিশনের অন্যতম সহজ কাজ হলো **ইমেজ ক্লাসিফিকেশন**।

কম্পিউটার ভিশন প্রায়ই কৃত্রিম বুদ্ধিমত্তার (AI) একটি শাখা হিসেবে বিবেচিত হয়। বর্তমানে, বেশিরভাগ কম্পিউটার ভিশনের কাজ নিউরাল নেটওয়ার্ক ব্যবহার করে সমাধান করা হয়। আমরা এই অধ্যায়ে কম্পিউটার ভিশনের জন্য ব্যবহৃত বিশেষ ধরনের নিউরাল নেটওয়ার্ক, [কনভলিউশনাল নিউরাল নেটওয়ার্ক](../07-ConvNets/README.md) সম্পর্কে আরও জানব।

তবে, একটি ইমেজ নিউরাল নেটওয়ার্কে পাঠানোর আগে, অনেক ক্ষেত্রে ইমেজ উন্নত করতে কিছু অ্যালগরিদমিক কৌশল ব্যবহার করা যৌক্তিক।

ইমেজ প্রসেসিংয়ের জন্য বেশ কয়েকটি পাইথন লাইব্রেরি উপলব্ধ:

* **[imageio](https://imageio.readthedocs.io/en/stable/)** বিভিন্ন ইমেজ ফরম্যাট পড়া/লেখার জন্য ব্যবহার করা যেতে পারে। এটি ffmpeg সমর্থন করে, যা ভিডিও ফ্রেমকে ইমেজে রূপান্তর করার একটি কার্যকরী টুল।
* **[Pillow](https://pillow.readthedocs.io/en/stable/index.html)** (PIL নামেও পরিচিত) আরও শক্তিশালী এবং এটি ইমেজ ম্যানিপুলেশন যেমন মর্ফিং, প্যালেট অ্যাডজাস্টমেন্ট ইত্যাদি সমর্থন করে।
* **[OpenCV](https://opencv.org/)** একটি শক্তিশালী ইমেজ প্রসেসিং লাইব্রেরি যা C++-এ লেখা হয়েছে এবং এটি ইমেজ প্রসেসিংয়ের জন্য *ডি ফ্যাক্টো* স্ট্যান্ডার্ড হয়ে উঠেছে। এর একটি সুবিধাজনক পাইথন ইন্টারফেস রয়েছে।
* **[dlib](http://dlib.net/)** একটি C++ লাইব্রেরি যা অনেক মেশিন লার্নিং অ্যালগরিদম বাস্তবায়ন করে, যার মধ্যে কিছু কম্পিউটার ভিশন অ্যালগরিদমও রয়েছে। এর একটি পাইথন ইন্টারফেস রয়েছে এবং এটি মুখ এবং ফেসিয়াল ল্যান্ডমার্ক ডিটেকশনের মতো চ্যালেঞ্জিং কাজের জন্য ব্যবহার করা যেতে পারে।

## OpenCV

[OpenCV](https://opencv.org/) ইমেজ প্রসেসিংয়ের জন্য *ডি ফ্যাক্টো* স্ট্যান্ডার্ড হিসেবে বিবেচিত হয়। এতে অনেক দরকারী অ্যালগরিদম রয়েছে, যা C++-এ বাস্তবায়িত। আপনি পাইথন থেকেও OpenCV কল করতে পারেন।

OpenCV শেখার একটি ভালো জায়গা হলো [এই Learn OpenCV কোর্স](https://learnopencv.com/getting-started-with-opencv/)। আমাদের পাঠ্যক্রমে, আমাদের লক্ষ্য OpenCV শেখা নয়, বরং এটি কখন এবং কীভাবে ব্যবহার করা যায় তার কিছু উদাহরণ দেখানো।

### ইমেজ লোড করা

পাইথনে ইমেজ সহজেই NumPy অ্যারে দ্বারা উপস্থাপন করা যায়। উদাহরণস্বরূপ, ৩২০x২০০ পিক্সেলের গ্রেস্কেল ইমেজ একটি ২০০x৩২০ অ্যারেতে সংরক্ষিত হবে, এবং একই মাত্রার রঙিন ইমেজের আকার হবে ২০০x৩২০x৩ (৩টি রঙ চ্যানেলের জন্য)। একটি ইমেজ লোড করতে, আপনি নিম্নলিখিত কোড ব্যবহার করতে পারেন:

```python
import cv2
import matplotlib.pyplot as plt

im = cv2.imread('image.jpeg')
plt.imshow(im)
```

ঐতিহ্যগতভাবে, OpenCV রঙিন ইমেজের জন্য BGR (নীল-সবুজ-লাল) এনকোডিং ব্যবহার করে, যেখানে পাইথনের অন্যান্য টুলগুলি আরও প্রচলিত RGB (লাল-সবুজ-নীল) ব্যবহার করে। ইমেজটি সঠিকভাবে দেখানোর জন্য, আপনাকে এটি RGB রঙ স্পেসে রূপান্তর করতে হবে, হয় NumPy অ্যারেতে ডাইমেনশন অদলবদল করে, অথবা একটি OpenCV ফাংশন কল করে:

```python
im = cv2.cvtColor(im,cv2.COLOR_BGR2RGB)
```

একই `cvtColor` ফাংশনটি অন্যান্য রঙ স্পেস রূপান্তর যেমন ইমেজকে গ্রেস্কেলে বা HSV (Hue-Saturation-Value) রঙ স্পেসে রূপান্তর করতেও ব্যবহার করা যেতে পারে।

আপনি OpenCV ব্যবহার করে ভিডিও ফ্রেম-বাই-ফ্রেম লোড করতে পারেন - একটি উদাহরণ [OpenCV Notebook](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb)-এ দেওয়া হয়েছে।

### ইমেজ প্রসেসিং

একটি ইমেজ নিউরাল নেটওয়ার্কে পাঠানোর আগে, আপনি কয়েকটি প্রি-প্রসেসিং ধাপ প্রয়োগ করতে চাইতে পারেন। OpenCV অনেক কিছু করতে পারে, যার মধ্যে রয়েছে:

* **ইমেজ রিসাইজ করা** `im = cv2.resize(im, (320,200),interpolation=cv2.INTER_LANCZOS)` ব্যবহার করে
* **ইমেজ ব্লার করা** `im = cv2.medianBlur(im,3)` বা `im = cv2.GaussianBlur(im, (3,3), 0)` ব্যবহার করে
* ইমেজের **উজ্জ্বলতা এবং কনট্রাস্ট পরিবর্তন** করা NumPy অ্যারে ম্যানিপুলেশন দ্বারা করা যেতে পারে, যেমনটি [এই Stackoverflow নোটে](https://stackoverflow.com/questions/39308030/how-do-i-increase-the-contrast-of-an-image-in-python-opencv) বর্ণনা করা হয়েছে।
* [থ্রেশোল্ডিং](https://docs.opencv.org/4.x/d7/d4d/tutorial_py_thresholding.html) ব্যবহার করা `cv2.threshold`/`cv2.adaptiveThreshold` ফাংশন কল করে, যা প্রায়ই উজ্জ্বলতা বা কনট্রাস্ট সামঞ্জস্য করার চেয়ে বেশি কার্যকর।
* ইমেজে বিভিন্ন [রূপান্তর](https://docs.opencv.org/4.5.5/da/d6e/tutorial_py_geometric_transformations.html) প্রয়োগ করা:
    - **[অ্যাফাইন রূপান্তর](https://docs.opencv.org/4.5.5/d4/d61/tutorial_warp_affine.html)** যদি আপনাকে ইমেজে ঘূর্ণন, রিসাইজিং এবং স্কিউয়িং একত্রিত করতে হয় এবং আপনি ইমেজের তিনটি পয়েন্টের উৎস এবং গন্তব্য অবস্থান জানেন। অ্যাফাইন রূপান্তর সমান্তরাল রেখাগুলিকে সমান্তরাল রাখে।
    - **[পার্সপেক্টিভ রূপান্তর](https://medium.com/analytics-vidhya/opencv-perspective-transformation-9edffefb2143)** যদি আপনি ইমেজের ৪টি পয়েন্টের উৎস এবং গন্তব্য অবস্থান জানেন। উদাহরণস্বরূপ, যদি আপনি একটি স্মার্টফোন ক্যামেরা দিয়ে একটি আয়তাকার ডকুমেন্টের ছবি তোলেন এবং আপনি ডকুমেন্টটির একটি আয়তাকার ইমেজ তৈরি করতে চান।
* ইমেজের ভেতরে গতিবিধি বোঝা **[অপটিক্যাল ফ্লো](https://docs.opencv.org/4.5.5/d4/dee/tutorial_optical_flow.html)** ব্যবহার করে।

## কম্পিউটার ভিশনের ব্যবহার উদাহরণ

আমাদের [OpenCV Notebook](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb)-এ, আমরা দেখিয়েছি কম্পিউটার ভিশন কীভাবে নির্দিষ্ট কাজ সম্পাদন করতে ব্যবহার করা যেতে পারে:

* **ব্রেইল বইয়ের একটি ছবির প্রি-প্রসেসিং**। আমরা দেখিয়েছি কীভাবে থ্রেশোল্ডিং, ফিচার ডিটেকশন, পার্সপেক্টিভ ট্রান্সফরমেশন এবং NumPy ম্যানিপুলেশন ব্যবহার করে পৃথক ব্রেইল প্রতীকগুলোকে আলাদা করা যায়, যা পরে একটি নিউরাল নেটওয়ার্ক দ্বারা শ্রেণীবদ্ধ করা হবে।

![ব্রেইল ইমেজ](../../../../../translated_images/braille.341962ff76b1bd7044409371d3de09ced5028132aef97344ea4b7468c1208126.bn.jpeg) | ![প্রি-প্রসেসড ব্রেইল ইমেজ](../../../../../translated_images/braille-result.46530fea020b03c76aac532d7d6eeef7f6fb35b55b1001cd21627907dabef3ed.bn.png) | ![ব্রেইল প্রতীক](../../../../../translated_images/braille-symbols.0159185ab69d533909dc4d7d26a1971b51401c6a80eb3a5584f250ea880af88b.bn.png)
----|-----|-----

> ছবি [OpenCV.ipynb](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb) থেকে

* **ফ্রেম ডিফারেন্স ব্যবহার করে ভিডিওতে গতিবিধি সনাক্তকরণ**। যদি ক্যামেরা স্থির থাকে, তাহলে ক্যামেরা ফিডের ফ্রেমগুলো একে অপরের সাথে বেশ মিল থাকবে। যেহেতু ফ্রেমগুলো অ্যারে হিসেবে উপস্থাপিত হয়, দুটি পরপর ফ্রেমের জন্য সেই অ্যারেগুলো বিয়োগ করলেই পিক্সেলের পার্থক্য পাওয়া যাবে, যা স্থির ফ্রেমের জন্য কম হবে এবং ইমেজে উল্লেখযোগ্য গতিবিধি থাকলে বেশি হবে।

![ভিডিও ফ্রেম এবং ফ্রেম ডিফারেন্সের ছবি](../../../../../translated_images/frame-difference.706f805491a0883c938e16447bf5eb2f7d69e812c7f743cbe7d7c7645168f81f.bn.png)

> ছবি [OpenCV.ipynb](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb) থেকে

* **অপটিক্যাল ফ্লো ব্যবহার করে গতিবিধি সনাক্তকরণ**। [অপটিক্যাল ফ্লো](https://docs.opencv.org/3.4/d4/dee/tutorial_optical_flow.html) আমাদের বুঝতে সাহায্য করে ভিডিও ফ্রেমের পৃথক পিক্সেলগুলো কীভাবে সরছে। অপটিক্যাল ফ্লোর দুটি ধরন রয়েছে:

   - **ডেন্স অপটিক্যাল ফ্লো** প্রতিটি পিক্সেলের জন্য একটি ভেক্টর ফিল্ড গণনা করে যা দেখায় এটি কোথায় সরছে।
   - **স্পার্স অপটিক্যাল ফ্লো** ইমেজের কিছু বৈশিষ্ট্যপূর্ণ অংশ (যেমন প্রান্ত) নিয়ে কাজ করে এবং ফ্রেম থেকে ফ্রেমে তাদের গতিপথ তৈরি করে।

![অপটিক্যাল ফ্লোর ছবি](../../../../../translated_images/optical.1f4a94464579a83a10784f3c07fe7228514714b96782edf50e70ccd59d2d8c4f.bn.png)

> ছবি [OpenCV.ipynb](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb) থেকে

## ✍️ উদাহরণ নোটবুক: OpenCV [OpenCV ইন অ্যাকশন চেষ্টা করুন](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb)

চলুন OpenCV নিয়ে কিছু পরীক্ষা-নিরীক্ষা করি [OpenCV Notebook](../../../../../lessons/4-ComputerVision/06-IntroCV/OpenCV.ipynb) অন্বেষণ করে।

## উপসংহার

কখনও কখনও, গতিবিধি সনাক্তকরণ বা আঙুলের ডগা সনাক্তকরণের মতো তুলনামূলকভাবে জটিল কাজ শুধুমাত্র কম্পিউটার ভিশন ব্যবহার করেই সমাধান করা যায়। তাই, কম্পিউটার ভিশনের মৌলিক কৌশল এবং OpenCV-এর মতো লাইব্রেরিগুলো কী করতে পারে তা জানা খুবই সহায়ক।

## 🚀 চ্যালেঞ্জ

AI শো থেকে [এই ভিডিওটি](https://docs.microsoft.com/shows/ai-show/ai-show--2021-opencv-ai-competition--grand-prize-winners--cortic-tigers--episode-32?WT.mc_id=academic-77998-cacaste) দেখুন Cortic Tigers প্রকল্প সম্পর্কে জানার জন্য এবং কীভাবে তারা একটি রোবটের মাধ্যমে কম্পিউটার ভিশন কাজগুলো গণতান্ত্রিক করতে ব্লক-ভিত্তিক সমাধান তৈরি করেছে। এরকম অন্যান্য প্রকল্প নিয়ে গবেষণা করুন যা নতুন শিক্ষার্থীদের এই ক্ষেত্রে অন্তর্ভুক্ত করতে সাহায্য করে।

## [পোস্ট-লেকচার কুইজ](https://red-field-0a6ddfd03.1.azurestaticapps.net/quiz/206)

## পর্যালোচনা ও স্ব-অধ্যয়ন

অপটিক্যাল ফ্লো সম্পর্কে আরও পড়ুন [এই চমৎকার টিউটোরিয়ালে](https://learnopencv.com/optical-flow-in-opencv/)।

## [অ্যাসাইনমেন্ট](lab/README.md)

এই ল্যাবে, আপনি সহজ অঙ্গভঙ্গি সহ একটি ভিডিও নেবেন এবং আপনার লক্ষ্য হবে অপটিক্যাল ফ্লো ব্যবহার করে উপরে/নিচে/বামে/ডানে গতিবিধি বের করা।

<img src="images/palm-movement.png" width="30%" alt="পাম মুভমেন্ট ফ্রেম"/>

**অস্বীকৃতি**:  
এই নথিটি AI অনুবাদ পরিষেবা [Co-op Translator](https://github.com/Azure/co-op-translator) ব্যবহার করে অনুবাদ করা হয়েছে। আমরা যথাসম্ভব সঠিক অনুবাদের চেষ্টা করি, তবে অনুগ্রহ করে মনে রাখবেন যে স্বয়ংক্রিয় অনুবাদে ত্রুটি বা অসঙ্গতি থাকতে পারে। নথিটির মূল ভাষায় লেখা সংস্করণটিকেই প্রামাণিক উৎস হিসেবে বিবেচনা করা উচিত। গুরুত্বপূর্ণ তথ্যের জন্য, পেশাদার মানব অনুবাদ ব্যবহার করার পরামর্শ দেওয়া হয়। এই অনুবাদ ব্যবহারের ফলে সৃষ্ট কোনো ভুল বোঝাবুঝি বা ভুল ব্যাখ্যার জন্য আমরা দায়ী নই।